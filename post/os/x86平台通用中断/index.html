<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>x86平台Linux中断机制 - Yuanye Ma's Blog
</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="Yuanye Ma"><meta name=description content="x86平台Linux中断机制 [toc] 基础知识 NMI不能被IF禁止，其中断向量号由系统固定分配。 外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.125.4"><link rel=canonical href=http://0.0.0.0:1313/post/os/x86%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.e826e860368147e5a6685e686355e4d7789023c18c9ea2e78b35f6786ce92736.css integrity="sha256-6CboYDaBR+WmaF5oY1Xk13iQI8GMnqLnizX2eGzpJzY=" media=screen crossorigin=anonymous><meta property="og:url" content="http://0.0.0.0:1313/post/os/x86%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD/"><meta property="og:site_name" content="Yuanye Ma's Blog"><meta property="og:title" content="x86平台Linux中断机制"><meta property="og:description" content="x86平台Linux中断机制 [toc] 基础知识 NMI不能被IF禁止，其中断向量号由系统固定分配。 外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-04-15T16:01:23+08:00"><meta property="article:modified_time" content="2019-04-15T16:01:23+08:00"><meta property="article:tag" content="操作系统"><meta itemprop=name content="x86平台Linux中断机制"><meta itemprop=description content="x86平台Linux中断机制 [toc] 基础知识 NMI不能被IF禁止，其中断向量号由系统固定分配。 外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽"><meta itemprop=datePublished content="2019-04-15T16:01:23+08:00"><meta itemprop=dateModified content="2019-04-15T16:01:23+08:00"><meta itemprop=wordCount content="9166"><meta itemprop=keywords content="操作系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="x86平台Linux中断机制"><meta name=twitter:description content="x86平台Linux中断机制 [toc] 基础知识 NMI不能被IF禁止，其中断向量号由系统固定分配。 外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=back-to-top></div><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>功不唐捐</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=http://0.0.0.0:1313/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://0.0.0.0:1313/post/>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://0.0.0.0:1313/tags/>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://0.0.0.0:1313/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://0.0.0.0:1313/about/>About</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>功不唐捐</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=http://0.0.0.0:1313/>Home</a></li><li class=menu-item><a class=menu-item-link href=http://0.0.0.0:1313/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=http://0.0.0.0:1313/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=http://0.0.0.0:1313/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=http://0.0.0.0:1313/about/>About</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight wallpaper"><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>x86平台Linux中断机制</h1><div class=post-meta><div class=post-meta-author>by
<a href=/about><span class=post-meta-author-name>Yuanye Ma</span></a></div><div class=post-meta-time><time datetime=2019-04-15>2019-04-15</time></div><div class=post-meta__right><div class=post-meta-category><a href=http://0.0.0.0:1313/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div></div></div></header><div class=post-content><h1 id=x86平台linux中断机制>x86平台Linux中断机制</h1><p>[toc]</p><h2 id=基础知识>基础知识</h2><p>NMI不能被IF禁止，其中断向量号由系统固定分配。</p><p>外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽中断，cpu直接在对应的中断向量表中取得中断入口地址，执行中断处理程序。而对于可屏蔽中断，一般是用8259A等中断管理器来管理。cpu从中断管理器中得到一个中断请求时，会去检查一下中断允许标志IF，若IF为1则取出中断类型码，从中断向量表中取得中断入口地址，执行中断处理程序。若IF为0，cpu将不响应外部提出的中断请求。</p><p><strong>IRQ</strong> : <code>Interrupt ReQuest</code></p><p><strong>PIC</strong> : <code>Programmable Interrupt Controller</code> 可编程中断控制器</p><p>向量：每个中断和异常，由0-255之间的数来标识，Intel把这个无符号的整数叫做向量（<code>vector</code>）</p><p>PIC的作用：</p><ol><li><p>监视IRQ线，检查产生的信号。</p></li><li><p>如果有引发信号出现在IRQ线上：</p><p>a. 把接收到的引发信号转换成对应的向量。<br>b. 把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读取此向量。<br>c. 把引发信号发送到处理器的<code>INTR</code>引脚，即产生一个中断。<br>d. 等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认，这种情况发生时，清<code>INTR</code>线。</p></li><li><p>返回第1步。</p></li></ol><p>IRQ线从0开始编号，因此<code>IRQn</code>关联的Intel的缺省向量是<code>n+32</code>(CPU保留了一部分向量来处理异常)。可以通过向中断控制器端口发布合适的指令，修改IRQ和向量之间的映射，以及有选择的禁止或者激活相应的IRQ，此禁止只是告诉PIC暂时不向CPU发布此IRQ中断，而一旦此IRQ被再次激活，PIC又会发送此IRQ给CPU 。可屏蔽中断的全局屏蔽或者非屏蔽，由CPU的<code>eflags</code>寄存器的<code>IF</code>标志位决定，<code>cli</code>和<code>sti</code>指令分别清楚和设置该标志。</p><p>传统的PIC由两片8259A外部芯片级联组成，只能作为单处理器的PIC。在SMP体系结构中，中断需要传递给系统中的每个CPU，为此Intel从Pentiun III开始引入I/O高级可编程控制器（<code>I/O Advanded Programmable Interrupt Controller, I/O APIC</code>）用以代替老式的8259A PIC。</p><p>多APIC结构：<strong><code>APIC</code>总线</strong>把“前端”<strong>I/O APIC</strong>连接到<strong>本地APIC</strong>。来自设备的<code>IRQ</code>线连接到<code>I/O APIC</code>，相对于本地APIC来说，<code>I/O APIC</code>起路由作用。 <code>I/O APIC</code>中的中断重定向表将每个外部IRQ信号转换为一条消息，然后，通过<code>APIC</code>总线发送给一个或多个CPU的本地<code>APIC</code>单元。多<code>APIC</code>系统还允许<code>CPU</code>产生处理器间中断（<code>interprocessor interrupt</code>, 简称<code>IPI</code>）。</p><p>目前大部分单处理器系统都包含一个I/O APIC芯片，可以用以下两种方式进行配置：</p><ul><li>作为一种标准的8259A方式的外部PIC连接到CPU。本地APIC被禁止，LINT0和LINT1本地IRQ线分别配置为INTR和NMI引脚。</li><li>作为一种标准的I/O APIC。本地APIC被激活，且所有的外部中断都通过I/O APIC接收。</li></ul><p><img alt=image-20201214121629804 src=/post/os/x86%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD/image-20201214121629804.png></p><p><strong>中断请求队列</strong></p><p>由于硬件的限制，很多外部设备不得不共享中断线，例如，一些PC配置可以把同一条中断线分配给网卡和图形卡。由此看来，让每个中断源都必须占用一条中断线是不现实的。所以，仅仅中断描述符表并不能提供中断产生的所有信息，内核必须对中断线给出进一步的描述。在Linux设计中，专门为每个中断请求IRQ设置了一个队列，这就是我们所说的中断请求队列。</p><h3 id=关于io-apic的一些更详细的资料>关于I/O APIC的一些更详细的资料</h3><p><a href=https://blog.csdn.net/jk198310/article/details/9250355>PIC 、APIC(IOAPIC LAPIC)</a></p><p><a href=https://blog.csdn.net/GerryLee93/article/details/106474994/>1. IO APIC</a></p><hr><p>Linux kernel version : <strong>linux 2.6.30.4</strong></p><h2 id=基本数据结构>基本数据结构</h2><p>由于通用中断门是让多个中断源共享的，而且允许这种公用的结构在系统运行的过程中动态地变化，所以IDT的初始化阶段只是为每个中断向量，也即每个表项准备一个“中断请求队列”， 从而形成一个中断请求队列的数组，这就是数组<code>irq_desc[]</code>。</p><p>每个队列头部中除了<code>action</code>用来维持一个由<strong>中断服务程序描述项目</strong>构成的<strong>单链队列</strong>外，还有个指针<code>handler</code>指向另一个数据结构，即<code>hw_interrupt_type</code>数据结构，此结构主要是一些函数指针，用于该队列，或者该共用“中断通道”的控制，并不对具体的中断源服务。具体的函数取决于<strong>所用的中断控制器</strong>(比如 i8259A)。其中，函数指针<code>enable</code>和<code>disable</code>用于开启和关闭其所属的通道，<code>ack</code>用于对中断控制器的相应，而<code>end</code>则用于每次中断服务返回的前夕，这些函数都是在<code>init_IRQ()</code>函数中调用<code>init_ISA_irqs()</code>设置好的。 [这两段摘自《Linux内核源代码情景分析》3.3小节]</p><p><img alt=image-20201214121841163 src=/post/os/x86%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD/image-20201214121841163.png></p><h3 id=irq_desc_t>irq_desc_t</h3><p>每个中断向量都有自己的<code>irq_desc_t</code>描述符，所有这些描述符组织在一起形成了<code>irq_desc</code>数组。</p><p>根据前一段书中的描述，<code>irq_desc</code>数组应该就是作者所说的中断请求队列数组，数组中的每一项即每一个<code>struct irq_desc</code>结构都描述一个“中断请求队列”，<code>struct irqaction</code>即中断服务程序构成的队列，队列中每一项都对应一个中断服务程序。<code>hw_interrupt_type</code>在较新版本的内核中被<code>struct irq_chip</code>取代，指代此中断通道的操作函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*include/linux/irq.h*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct irq_desc - interrupt descriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @irq:                interrupt number for this descriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @timer_rand_state:   pointer to timer rand state struct
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @kstat_irqs:         irq stats per cpu
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @irq_2_iommu:        iommu with this irq
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @handle_irq:         highlevel irq-events handler [if NULL, __do_IRQ()]
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @chip:               low level interrupt hardware access
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @msi_desc:           MSI descriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @handler_data:       per-IRQ data for the irq_chip methods
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @chip_data:          platform-specific per-chip private data for the chip
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                      methods, to allow shared chip implementations
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @action:             the irq action chain
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @status:             status information
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @depth:              disable-depth, for nested irq_disable() calls
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @wake_depth:         enable depth, for multiple set_irq_wake() callers
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @irq_count:          stats field to detect stalled irqs
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @last_unhandled:     aging timer for unhandled count
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @irqs_unhandled:     stats field for spurious unhandled interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @lock:               locking for SMP
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @affinity:           IRQ affinity on SMP
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @cpu:                cpu index useful for balancing
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pending_mask:       pending rebalanced interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @threads_active:     number of irqaction threads currently running
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @wait_for_threads:   wait queue for sync_irq to wait for threaded handlers
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @dir:                /proc/irq/ procfs entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @name:               flow handler name for /proc/interrupts output
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_desc {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            irq;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> timer_rand_state <span style=color:#f92672>*</span>timer_rand_state;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            <span style=color:#f92672>*</span>kstat_irqs;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_INTR_REMAP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>struct</span> irq_2_iommu      <span style=color:#f92672>*</span>irq_2_iommu;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>irq_flow_handler_t</span>      handle_irq;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irq_chip         <span style=color:#f92672>*</span>chip;			<span style=color:#75715e>/*指向描述PIC对象的描述符*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> msi_desc         <span style=color:#f92672>*</span>msi_desc;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>                    <span style=color:#f92672>*</span>handler_data;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>                    <span style=color:#f92672>*</span>chip_data;		<span style=color:#75715e>/* 指向PIC对象方法所使用的的数据 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irqaction        <span style=color:#f92672>*</span>action;        <span style=color:#75715e>/* IRQ action list */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            status;         <span style=color:#75715e>/* IRQ status */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            depth;          <span style=color:#75715e>/* nested irq disables */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            wake_depth;     <span style=color:#75715e>/* nested wake enables */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            irq_count;      <span style=color:#75715e>/* For detecting broken IRQs */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           last_unhandled; <span style=color:#75715e>/* Aging timer for unhandled count */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            irqs_unhandled;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>spinlock_t</span>              lock;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_SMP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>cpumask_var_t</span>           affinity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            cpu;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_GENERIC_PENDING_IRQ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>cpumask_var_t</span>           pending_mask;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>atomic_t</span>                threads_active;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>wait_queue_head_t</span>       wait_for_threads;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_PROC_FS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>struct</span> proc_dir_entry   <span style=color:#f92672>*</span>dir;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>              <span style=color:#f92672>*</span>name;
</span></span><span style=display:flex><span>} ____cacheline_internodealigned_in_smp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>struct</span> irq_desc irq_desc[NR_IRQS];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* include/linux/cache.h */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if !defined(____cacheline_internodealigned_in_smp)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if defined(CONFIG_SMP)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define ____cacheline_internodealigned_in_smp \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        __attribute__((__aligned__(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define ____cacheline_internodealigned_in_smp
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* struct irq_desc的status字段，描述IRQ线的一组状态 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        [<span style=color:#ae81ff>0</span> ... NR_IRQS<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>                .status <span style=color:#f92672>=</span> IRQ_DISABLED,
</span></span><span style=display:flex><span>                .chip <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>no_irq_chip,
</span></span><span style=display:flex><span>                .handle_irq <span style=color:#f92672>=</span> handle_bad_irq,
</span></span><span style=display:flex><span>                .depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                .lock <span style=color:#f92672>=</span> <span style=color:#a6e22e>__SPIN_LOCK_UNLOCKED</span>(irq_desc<span style=color:#f92672>-&gt;</span>lock),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>irq_desc_t</code>描述的<code>depth</code>字段和<code>IRQ_DISABLED</code>标志表示<code>IRQ</code>线是否被禁用。每次调用<code>disable_irq()</code>或者<code>disale_irq_nosync()</code>函数，<code>depth</code>字段的值增加，如果<code>depth</code>等于0，函数禁用<code>IRQ</code>线并设置它的<code>IRQ_DISABLED</code>标志相反，每当调用<code>enable_irq()</code>函数，<code>depth</code>字段的值减少，如果<code>depth</code>变为0，函数激活<code>IRQ</code>线并清除<code>IRQ_DISABLED</code>标志。</p><h3 id=irq_chip>irq_chip</h3><p>Linux支持多种<code>PIC</code>，为了以统一的方式处理所有这样的设备，Linux用了一个<code>PIC对象</code>，由<code>PIC</code>名字和七个<code>PIC</code>标准方法组成。定义<code>PIC对象</code>的数据结构叫做<code>hw_interrupt_type</code>（也叫作<code>hw_irq_controller</code>），后来被<code>irq_chip</code>取代，并添加了很多新的底层硬件操作函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*include/linux/irq.h*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct irq_chip - hardware interrupt chip descriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @name:               name for /proc/interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @startup:            start up the interrupt (defaults to -&gt;enable if NULL)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @shutdown:           shut down the interrupt (defaults to -&gt;disable if NULL)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @enable:             enable the interrupt (defaults to chip-&gt;unmask if NULL)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @disable:            disable the interrupt (defaults to chip-&gt;mask if NULL)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ack:                start of a new interrupt
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @mask:               mask an interrupt source
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @mask_ack:           ack and mask an interrupt source
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @unmask:             unmask an interrupt source
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @eoi:                end of interrupt - chip level
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @end:                end of interrupt - flow level
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @set_affinity:       set the CPU affinity on SMP machines
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @retrigger:          resend an IRQ to the CPU
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @set_type:           set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @set_wake:           enable/disable power-management wake-on of an IRQ
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @release:            release function solely used by UML
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @typename:           obsoleted by name, kept as migration helper
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_chip {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>      <span style=color:#f92672>*</span>name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#a6e22e>int</span>    (<span style=color:#f92672>*</span>startup)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>shutdown)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>enable)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>disable)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>ack)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>mask)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>mask_ack)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>unmask)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>eoi)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>end)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>set_affinity)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq,
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> cpumask <span style=color:#f92672>*</span>dest);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span>             (<span style=color:#f92672>*</span>retrigger)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span>             (<span style=color:#f92672>*</span>set_type)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flow_type);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span>             (<span style=color:#f92672>*</span>set_wake)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> on);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Currently used only by UML, might disappear one day.*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_IRQ_RELEASE_METHOD
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span>            (<span style=color:#f92672>*</span>release)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * For compatibility, -&gt;typename is copied into -&gt;name.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Will disappear.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>      <span style=color:#f92672>*</span><span style=color:#66d9ef>typename</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=irqaction>irqaction</h3><p>多个设备能共享一个单独的<code>IRQ</code>，因此，内核要维护多个<code>irqaction</code>描述符，其中的每个描述符涉及一个特定的硬件设备和一个特定的中断。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* include/linux/interrupt.h */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct irqaction - per interrupt action descriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @handler:    interrupt handler function
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @flags:      flags (see IRQF_* above)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @mask:       no comment as it is useless and about to be removed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @name:       name of the device
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @dev_id:     cookie to identify the device
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @next:       pointer to the next irqaction for shared interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @irq:        interrupt number
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @dir:        pointer to the proc/irq/NN/name entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @thread_fn:  interupt handler function for threaded interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @thread:     thread pointer for threaded interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @thread_flags:       flags related to @thread
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irqaction {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>irq_handler_t</span> handler; <span style=color:#75715e>/* 指向一个I/O设备的中断服务例程 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;   <span style=color:#75715e>/* 描述IRQ和I/O设备之间的关系 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>cpumask_t</span> mask;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;		<span style=color:#75715e>/* I/O设备名，/proc/interrupts文件中显示 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id;			<span style=color:#75715e>/* I/O设备的私有字段，标识设备本身(设备号)或者其驱动程序 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irqaction <span style=color:#f92672>*</span>next; <span style=color:#75715e>/* 指向irqaction描述符链表的下一个元素，链表中的元素指向共享同一个IRQ的硬件设备 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> irq;				<span style=color:#75715e>/* IRQ线 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> proc_dir_entry <span style=color:#f92672>*</span>dir; <span style=color:#75715e>/* 指向IRQn相关的/proc/irq/n目录的描述符 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>irq_handler_t</span> thread_fn;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span><span style=color:#66d9ef>thread</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> thread_flags;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>/* 中断服务函数类型 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>irqreturn_t</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>irq_handler_t</span>)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
</span></span></code></pre></div><h2 id=中断初始化>中断初始化</h2><p>x86平台中断初始化共分为以下几步：</p><ul><li>中断描述符表的初步初始化</li><li>中断描述符表的最终初始化</li><li><code>trap_init()</code></li><li><code>early_irq_init()</code></li><li><code>init_IRQ()</code></li></ul><h3 id=idt初步初始化><code>IDT</code>初步初始化</h3><ol><li><p>声明256个门描述符的<code>IDT</code>表空间</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* arch/x86/kernel/head_32.S */</span>
</span></span><span style=display:flex><span>idt_descr:
</span></span><span style=display:flex><span>        .word IDT_ENTRIES<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>           <span style=color:#960050;background-color:#1e0010>#</span> idt contains <span style=color:#ae81ff>256</span> entries
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>long</span> idt_table
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	这里相当于声明了一个结构体idt_descr，包含两个元素，一个数字和idt_table的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e>	arch/x86/include/asm/desc.h:35:extern gate_desc idt_table[];声明idt_table是一个外部变量，即head_32.S中的idt_descr中的idt_table.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	idt_table表的内容被_set_gate() -&gt; write_idt_entry()填充。	
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define write_idt_entry(dt, entry, g)           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        native_write_idt_entry(dt, entry, g)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>native_write_idt_entry</span>(gate_desc <span style=color:#f92672>*</span>idt, <span style=color:#66d9ef>int</span> entry,
</span></span><span style=display:flex><span>                                          <span style=color:#66d9ef>const</span> gate_desc <span style=color:#f92672>*</span>gate)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>memcpy</span>(<span style=color:#f92672>&amp;</span>idt[entry], gate, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>gate));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	_set_gate()函数被set_xxxintr_gate()调用，用以设置中断门，陷阱门等。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	函数被set_xxxintr_gate()函数主要在
</span></span></span><span style=display:flex><span><span style=color:#75715e>		start_kernel()
</span></span></span><span style=display:flex><span><span style=color:#75715e>			-&gt;trap_init()
</span></span></span><span style=display:flex><span><span style=color:#75715e>			-&gt;init_IQR()
</span></span></span><span style=display:flex><span><span style=color:#75715e>	被调用	
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div></li><li><p>设置<code>IDTR</code></p><pre tabindex=0><code class=language-assembly data-lang=assembly>is386:  movl $2,%ecx            # set MP
2:      movl %cr0,%eax
        andl $0x80000011,%eax   # Save PG,PE,ET
        orl %ecx,%eax
        movl %eax,%cr0

        call check_x87
        lgdt early_gdt_descr
        lidt idt_descr
        ljmp $(__KERNEL_CS),$1f
1:      movl $(__KERNEL_DS),%eax        # reload all the segment registers
        movl %eax,%ss                   # after changing gdt.
</code></pre></li><li><p>初始化256个门描述符</p><pre tabindex=0><code class=language-assembly data-lang=assembly>/*
 *  setup_idt
 *
 *  sets up a idt with 256 entries pointing to
 *  ignore_int, interrupt gates. It doesn&#39;t actually load
 *  idt - that can be done only after paging has been enabled
 *  and the kernel moved to PAGE_OFFSET. Interrupts
 *  are enabled elsewhere, when we can be relatively
 *  sure everything is ok.
 *
 *  Warning: %esi is live across this function.
 */
setup_idt:
        lea ignore_int,%edx
        movl $(__KERNEL_CS &lt;&lt; 16),%eax
        movw %dx,%ax            /* selector = 0x0010 = cs */
        movw $0x8E00,%dx        /* interrupt gate - dpl=0, present */

        lea idt_table,%edi 
        mov $256,%ecx
rp_sidt:
    movl %eax,(%edi)
        movl %edx,4(%edi)
        addl $8,%edi
        dec %ecx
        jne rp_sidt
</code></pre><blockquote><p>lea指令 ： load effective address 功能是取偏移地址。</p><p>mov是将数据从源传到目的</p><p>lea是将源的地址传到目的</p><p>例如：</p><p>​ movl 18(%eax), %ebx #是将内存中（%eax+18）的内容传入%ebx中；</p><p>​ leal 18(%eax), %ebx #是将（18+（%eax中的值））即地址，传入%ebx;</p><p>代码中，lea idt_table, %edi #即将idt_table表的地址传到%edi中。</p></blockquote></li></ol><h3 id=idt最终初始化><code>IDT</code>最终初始化</h3><ul><li>异常：由函数trap_init()实现，被系统初始化入口函数start_kernel()调用；</li><li>中断：由函数init_IRQ()实现，被系统初始化入口函数start_kernel()调用；</li></ul><h3 id=trap_init><code>trap_init()</code></h3><p>此函数在<strong>x86平台linux系统调用</strong>章节已经分析过。</p><h3 id=early_irq_init><code>early_irq_init()</code></h3><p>该函数用于初始化数组irq_desc[]；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	init/main.c-&gt;start_kernel()-&gt;early_irq_init()
</span></span></span><span style=display:flex><span><span style=color:#75715e>	early_irq_init()定义在kernel/irq/handle.c中，且针对不同的controller有不同的实现。	
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Linux has a controller-independent interrupt architecture.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Every controller has a &#39;controller-template&#39;, that is used
</span></span></span><span style=display:flex><span><span style=color:#75715e> * by the main code to do the right thing. Each driver-visible
</span></span></span><span style=display:flex><span><span style=color:#75715e> * interrupt source is transparently wired to the appropriate
</span></span></span><span style=display:flex><span><span style=color:#75715e> * controller. Thus drivers need not be aware of the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * interrupt-controller.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The code is designed to be easily extended with new/different
</span></span></span><span style=display:flex><span><span style=color:#75715e> * interrupt controllers, without having to do assembly magic or
</span></span></span><span style=display:flex><span><span style=color:#75715e> * having to touch the generic code.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Controller mappings for all interrupt sources:
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> nr_irqs <span style=color:#f92672>=</span> NR_IRQS;
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL_GPL</span>(nr_irqs);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_SPARSE_IRQ </span><span style=color:#75715e>/*CONFIG_SPARSE_IRQ=y支持稀有的中断号*/</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* 暂时不看 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        [<span style=color:#ae81ff>0</span> ... NR_IRQS<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>                .status <span style=color:#f92672>=</span> IRQ_DISABLED,
</span></span><span style=display:flex><span>                .chip <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>no_irq_chip,
</span></span><span style=display:flex><span>                .handle_irq <span style=color:#f92672>=</span> handle_bad_irq,
</span></span><span style=display:flex><span>                .depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                .lock <span style=color:#f92672>=</span> <span style=color:#a6e22e>__SPIN_LOCK_UNLOCKED</span>(irq_desc<span style=color:#f92672>-&gt;</span>lock),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> kstat_irqs_all[NR_IRQS][NR_CPUS];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>early_irq_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span>desc;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>init_irq_default_affinity</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printk</span>(KERN_INFO <span style=color:#e6db74>&#34;NR_IRQS:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, NR_IRQS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        desc <span style=color:#f92672>=</span> irq_desc;
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> <span style=color:#a6e22e>ARRAY_SIZE</span>(irq_desc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                desc[i].irq <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>init_alloc_desc_masks</span>(<span style=color:#f92672>&amp;</span>desc[i], <span style=color:#ae81ff>0</span>, true);
</span></span><span style=display:flex><span>                desc[i].kstat_irqs <span style=color:#f92672>=</span> kstat_irqs_all[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arch_early_irq_init</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span><span style=color:#a6e22e>irq_to_desc</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (irq <span style=color:#f92672>&lt;</span> NR_IRQS) <span style=color:#f92672>?</span> irq_desc <span style=color:#f92672>+</span> irq : NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span><span style=color:#a6e22e>irq_to_desc_alloc_cpu</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>int</span> cpu)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>irq_to_desc</span>(irq);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>/* !CONFIG_SPARSE_IRQ */</span><span style=color:#75715e>
</span></span></span></code></pre></div><h3 id=init_irq><code>init_IRQ()</code></h3><p><code>init/main.c->start_kernel()->init_IRQ()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* early_irq_init()函数调用完紧接着就是init_IQR()函数 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*arch/x86/kernel/paravirt.c*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_IRQ</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        pv_irq_ops.<span style=color:#a6e22e>init_IRQ</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*pv_irq_ops的定义在arch/x86/kernel/paravirt.c*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pv_irq_ops pv_irq_ops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .init_IRQ <span style=color:#f92672>=</span> native_init_IRQ,
</span></span><span style=display:flex><span>        .save_fl <span style=color:#f92672>=</span> <span style=color:#a6e22e>__PV_IS_CALLEE_SAVE</span>(native_save_fl),
</span></span><span style=display:flex><span>        .restore_fl <span style=color:#f92672>=</span> <span style=color:#a6e22e>__PV_IS_CALLEE_SAVE</span>(native_restore_fl),
</span></span><span style=display:flex><span>        .irq_disable <span style=color:#f92672>=</span> <span style=color:#a6e22e>__PV_IS_CALLEE_SAVE</span>(native_irq_disable),
</span></span><span style=display:flex><span>        .irq_enable <span style=color:#f92672>=</span> <span style=color:#a6e22e>__PV_IS_CALLEE_SAVE</span>(native_irq_enable),
</span></span><span style=display:flex><span>        .safe_halt <span style=color:#f92672>=</span> native_safe_halt,
</span></span><span style=display:flex><span>        .halt <span style=color:#f92672>=</span> native_halt,
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_X86_64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .adjust_exception_frame <span style=color:#f92672>=</span> paravirt_nop,
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 这里的调用关系搞不清楚是通过paravirt.c中的init_IRQ还是直接调用的irqinit_32.c中的init_IRQ然后再调用的native_init_IRQ, 通过irqinit_32.c中的注释：Overridden in paravirt.c 推断应该是直接调用的irqinit_32.c中的代码*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*arch/x86/kernel/irqinit_32.c*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Overridden in paravirt.c */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_IRQ</span>(<span style=color:#66d9ef>void</span>) <span style=color:#a6e22e>__attribute__</span>((weak, <span style=color:#a6e22e>alias</span>(<span style=color:#e6db74>&#34;native_init_IRQ&#34;</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>native_init_IRQ</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Execute any quirks before the call gates are initialised: */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x86_quirk_pre_intr_init</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Cover the whole vector space, no vector can escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * us. (some of these will be overridden and become
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * &#39;special&#39; SMP interrupts)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span>  FIRST_EXTERNAL_VECTOR; i <span style=color:#f92672>&lt;</span> NR_VECTORS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* SYSCALL_VECTOR was reserved in trap_init. */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> SYSCALL_VECTOR)
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>set_intr_gate</span>(i, interrupt[i<span style=color:#f92672>-</span>FIRST_EXTERNAL_VECTOR]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*略*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>_<em>attribute</em>_((weak, alias(&ldquo;native_init_IRQ&rdquo;)));</p><p>weak 和 alias 分别是GNU扩展的两个属性。</p><p>weak 使得所修饰的符号在目标文件中作为 weak symbol 而不是 global symbol。用 nm 命令查看编译生成的目标文件可用看到所修饰的符号是一个 weak symbol，它前面的标记是 W。给函数加上weak属性时，即使函数没定义，函数被调用也可以编译成功。 若两个或两个以上全局符号（函数或变量名）名字一样，而其中之一声明为weak symbol（弱符号），则这些全局符号不会引发重定义错误。链接器会忽略弱符号，去使用普通的全局符号来解析所有对这些符号的引用，但当普通的全局符号不可用时，链接器会使用弱符号。当有函数或变量名可能被用户覆盖时，该函数或变量名可以声明为一个弱符号。</p><p>而 alias 为所修饰的符号定义一个别名，前边代码中init_IRQ是native_init_IRQ的一个别名，所定义的别名和原符号名必须在同一个编译单元中定义，如native_init_IRQ和init_IRQ在同一个.c文件中，否则会编译出错。</p><p><a href=http://www.techbulo.com/2374.html>参考</a></p></blockquote><p>其中<code>x86_quirk_pre_intr_init</code>函数定义在<code>arch/x86/kernel/setup.c</code>中，主要调用了<code>init_ISA_irqs</code>函数完成中断控制器8259A的初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * x86_quirk_pre_intr_init - initialisation prior to setting up interrupt vectors
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Description:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      Perform any necessary interrupt initialisation prior to setting up
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      the &#34;ordinary&#34; interrupt call gates.  For legacy reasons, the ISA
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      interrupts should be initialised here if the machine emulates a PC
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      in any way.
</span></span></span><span style=display:flex><span><span style=color:#75715e> **/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>x86_quirk_pre_intr_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x86_quirks<span style=color:#f92672>-&gt;</span>arch_pre_intr_init) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (x86_quirks<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>arch_pre_intr_init</span>())
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>init_ISA_irqs</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* init_ISA_irqs函数定义在arch/x86/kernel/irqinit_32.c中 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>init_ISA_irqs</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_X86_LOCAL_APIC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>init_bsp_APIC</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>init_8259A</span>(<span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 完成8259A中断控制器的初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 16 old-style INTA-cycle interrupts:
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NR_IRQS_LEGACY; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span>desc <span style=color:#f92672>=</span> <span style=color:#a6e22e>irq_to_desc</span>(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                desc<span style=color:#f92672>-&gt;</span>status <span style=color:#f92672>=</span> IRQ_DISABLED;
</span></span><span style=display:flex><span>                desc<span style=color:#f92672>-&gt;</span>action <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>                desc<span style=color:#f92672>-&gt;</span>depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>set_irq_chip_and_handler_name</span>(i, <span style=color:#f92672>&amp;</span>i8259A_chip,
</span></span><span style=display:flex><span>                                              handle_level_irq, <span style=color:#e6db74>&#34;XT&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    	<span style=color:#75715e>/* for循环中初始化了16个 irq_desc_t描述符，*/</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 其中 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_chip i8259A_chip <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .name           <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XT-PIC&#34;</span>,
</span></span><span style=display:flex><span>        .mask           <span style=color:#f92672>=</span> disable_8259A_irq,
</span></span><span style=display:flex><span>        .disable        <span style=color:#f92672>=</span> disable_8259A_irq,
</span></span><span style=display:flex><span>        .unmask         <span style=color:#f92672>=</span> enable_8259A_irq,
</span></span><span style=display:flex><span>        .mask_ack       <span style=color:#f92672>=</span> mask_and_ack_8259A,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>handle_level_irq</span>()  <span style=color:#960050;background-color:#1e0010>定义在</span> <span style=color:#f92672>/</span>kernel<span style=color:#f92672>/</span>irq<span style=color:#f92672>/</span>chip.c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* /kernel/irq/chip.c&#34;  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>set_irq_chip_and_handler_name</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>struct</span> irq_chip <span style=color:#f92672>*</span>chip,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>irq_flow_handler_t</span> handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>set_irq_chip</span>(irq, chip); <span style=color:#75715e>/* 设置chip */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>__set_irq_handler</span>(irq, handle, <span style=color:#ae81ff>0</span>, name); 
</span></span><span style=display:flex><span>    			<span style=color:#75715e>/* 设置handle 
</span></span></span><span style=display:flex><span><span style=color:#75715e>                	desc-&gt;handle_irq = handle;
</span></span></span><span style=display:flex><span><span style=color:#75715e>			        desc-&gt;name = name;
</span></span></span><span style=display:flex><span><span style=color:#75715e>				*/</span> 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* /kernel/irq/chip.c */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      set_irq_chip - set the irq chip for an irq
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @irq:   irq number
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @chip:  pointer to irq chip description structure
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>set_irq_chip</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>struct</span> irq_chip <span style=color:#f92672>*</span>chip)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span>desc <span style=color:#f92672>=</span> <span style=color:#a6e22e>irq_to_desc</span>(irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>desc) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>WARN</span>(<span style=color:#ae81ff>1</span>, KERN_ERR <span style=color:#e6db74>&#34;Trying to install chip for IRQ%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, irq);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EINVAL;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>chip)
</span></span><span style=display:flex><span>                chip <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>no_irq_chip;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock_irqsave</span>(<span style=color:#f92672>&amp;</span>desc<span style=color:#f92672>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>irq_chip_set_defaults</span>(chip);
</span></span><span style=display:flex><span>        desc<span style=color:#f92672>-&gt;</span>chip <span style=color:#f92672>=</span> chip;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_unlock_irqrestore</span>(<span style=color:#f92672>&amp;</span>desc<span style=color:#f92672>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>之后循环调用<code>set_intr_gate</code>函数，完成中断门的初始化。循环中的几个宏定义如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*arch/x86/include/asm/irq_vectors.h*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * IDT vectors usable for external interrupt sources start
</span></span></span><span style=display:flex><span><span style=color:#75715e> * at 0x20:
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FIRST_EXTERNAL_VECTOR           0x20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NR_VECTORS                       256
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># define SYSCALL_VECTOR                 0x80
</span></span></span></code></pre></div><p>即初始化<code>IDT</code>从<code>0x20</code>开始的256个中断门，并跳过<code>0x80</code>。<code>set_intr_gate</code>函数定义在<code>arch/x86/include/asm/desc.h</code>中，定义如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This needs to use &#39;idt_table&#39; rather than &#39;idt&#39;, and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * thus use the _nonmapped_ version of the IDT, as the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Pentium F0 0F bugfix can have resulted in the mapped
</span></span></span><span style=display:flex><span><span style=color:#75715e> * IDT being write-protected.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_intr_gate</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>((<span style=color:#66d9ef>unsigned</span>)n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0xFF</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_set_gate</span>(n, GATE_INTERRUPT, addr, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, __KERNEL_CS);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	其中 GATE_INTERRUPT定义如下
</span></span></span><span style=display:flex><span><span style=color:#75715e>	arch/x86/include/asm/desc_defs.h&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>	enum {
</span></span></span><span style=display:flex><span><span style=color:#75715e>        GATE_INTERRUPT = 0xE,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        GATE_TRAP = 0xF,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        GATE_CALL = 0xC,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        GATE_TASK = 0x5,
</span></span></span><span style=display:flex><span><span style=color:#75715e>	};
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>简单总结<code>native_init_IRQ</code>函数主要完成两个工作，</p><ul><li>初始化中断控制器；<ul><li>初始化<code>struct desc</code>主要是<code>chip</code>成员和<code>handle_irq</code>成员。</li></ul></li><li>将<code>interrupt[]</code>数组中的中断服务程序地址写进了<code>IDT</code>中。</li></ul><h4 id=interrupt的定义>interrupt[]的定义</h4><p><a href=/post/os/x86%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD/#参考>参考</a>的第二项：中断之中断向量表IDT的初始化，有对这段代码的注释以及解释。</p><pre tabindex=0><code class=language-assembly data-lang=assembly>/*arch/x86/kernel/entry_32.S*/
/*
 * Build the entry stubs and pointer table with some assembler magic.
 * We pack 7 stubs into a single 32-byte chunk, which will fit in a
 * single cache line on all modern x86 implementations.
 */
.section .init.rodata,&#34;a&#34;
ENTRY(interrupt)
.text
        .p2align 5
        .p2align CONFIG_X86_L1_CACHE_SHIFT
ENTRY(irq_entries_start)
        RING0_INT_FRAME
vector=FIRST_EXTERNAL_VECTOR
.rept (NR_VECTORS-FIRST_EXTERNAL_VECTOR+6)/7
        .balign 32
  .rept 7
    .if vector &lt; NR_VECTORS
      .if vector &lt;&gt; FIRST_EXTERNAL_VECTOR
        CFI_ADJUST_CFA_OFFSET -4
      .endif
1:      pushl $(~vector+0x80)   /* Note: always in signed byte range */
        CFI_ADJUST_CFA_OFFSET 4
      .if ((vector-FIRST_EXTERNAL_VECTOR)%7) &lt;&gt; 6
        jmp 2f
      .endif
      .previous
        .long 1b
      .text
vector=vector+1
    .endif
  .endr
2:      jmp common_interrupt
.endr
END(irq_entries_start)

.previous
END(interrupt)
.previous
</code></pre><p>主要包含两行代码<code>pushl $(~vector+0x80) </code>和<code>jmp common_interrupt</code>,即把中断号减去256的结果保存到栈中，然后调用通用中断处理程序。之所以要减去256，是因为内核用负数表示所有的中断，正数表示系统调用。</p><blockquote><p>.rept语法</p><p>.rept <em>count</em>
Repeat the sequence of lines between the .rept directive and the next .endr directive count times.
For example, assembling
<strong>.rept 3
.long 0
.endr</strong>
is equivalent to assembling
<strong>.long 0
.long 0
.long 0</strong></p><p><a href=https://blog.csdn.net/waverider2012/article/details/8524175>参考</a></p><hr><p>.IF、.ELSE、.ELSEIF 和 .ENDIF 伪指令使得程序员易于对多分支逻辑进行编码。它们让汇编器在后台生成 CMP 和条件跳转指令，这些指令显示在输出列表文件中。语法如下所示：</p><p>.IF conditionl
statements
[.ELSEIF condition2
statements ]
[.ELSE
statements ]
.ENDIF</p><p>方括号表示 .ELSEIF 和 .ELSE 是可选的，而 .IF 和 .ENDIF 则是必需的。condition（条件）是布尔表达式，</p><p><a href=http://c.biancheng.net/view/3585.html>参考</a></p></blockquote><p>数组中每个元素的初始值是标号1的地址。因此访问数组中的元素时，都会跳到标号1处，执行相应的指令。也就是，在除了0~19号和0x80号中断外，其余的所有中断在进入其自己的中断服务程序之前，必须是先条转执行common_interrupt的.</p><h4 id=common_interrupt的定义>common_interrupt的定义</h4><pre tabindex=0><code class=language-assembly data-lang=assembly>
/*
 * the CPU automatically disables interrupts when executing an IRQ vector,
 * so IRQ-flags tracing has to follow that:
 */
        .p2align CONFIG_X86_L1_CACHE_SHIFT
common_interrupt:
        addl $-0x80,(%esp)      /* Adjust vector into the [-256,-1] range */
        SAVE_ALL
        TRACE_IRQS_OFF
        movl %esp,%eax
        call do_IRQ
        jmp ret_from_intr
ENDPROC(common_interrupt)
        CFI_ENDPROC
</code></pre><p>保存寄存器的值以后，栈顶的地址被存放到<code>eax</code>寄存器，然后中断处理程序调用<code>do_IRQ()</code>函数，执行<code>do_IRQ()</code>的<code>ret</code>指令时，控制跳转到<code>ret_from_intr()</code>。</p><h4 id=do_irq函数>do_IRQ函数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* arch/x86/kernel/irq.c */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * do_IRQ handles all normal device IRQ&#39;s (the special
</span></span></span><span style=display:flex><span><span style=color:#75715e> * SMP cross-CPU interrupts have their own specific
</span></span></span><span style=display:flex><span><span style=color:#75715e> * handlers).
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> __irq_entry <span style=color:#a6e22e>do_IRQ</span>(<span style=color:#66d9ef>struct</span> pt_regs <span style=color:#f92672>*</span>regs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> pt_regs <span style=color:#f92672>*</span>old_regs <span style=color:#f92672>=</span> <span style=color:#a6e22e>set_irq_regs</span>(regs);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* high bit used in ret_from_ code  */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> vector <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>regs<span style=color:#f92672>-&gt;</span>orig_ax; <span style=color:#75715e>// 取得对应的中断向量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsigned</span> irq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit_idle</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>irq_enter</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        irq <span style=color:#f92672>=</span> <span style=color:#a6e22e>__get_cpu_var</span>(vector_irq)[vector];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>handle_irq</span>(irq, regs)) { <span style=color:#75715e>//调用中断处理句柄，对8259，就是handle_level_irq
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifdef CONFIG_X86_64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>disable_apic)
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>ack_APIC_irq</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>printk_ratelimit</span>())
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>printk</span>(KERN_EMERG <span style=color:#e6db74>&#34;%s: %d.%d No irq handler for vector (irq %d)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                               __func__, <span style=color:#a6e22e>smp_processor_id</span>(), vector, irq);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>irq_exit</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>set_irq_regs</span>(old_regs);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=handle_irq>handle_irq</h4><p>搜索发现此函数在<code>arch/x86/kernel/irq_32.c"</code>中定义</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handle_irq</span>(<span style=color:#66d9ef>unsigned</span> irq, <span style=color:#66d9ef>struct</span> pt_regs <span style=color:#f92672>*</span>regs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span>desc;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> overflow;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        overflow <span style=color:#f92672>=</span> <span style=color:#a6e22e>check_stack_overflow</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        desc <span style=color:#f92672>=</span> <span style=color:#a6e22e>irq_to_desc</span>(irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#f92672>!</span>desc))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>execute_on_irq_stack</span>(overflow, desc, irq)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(overflow))
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>print_stack_overflow</span>();
</span></span><span style=display:flex><span>                desc<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>handle_irq</span>(irq, desc); 
</span></span><span style=display:flex><span>            	<span style=color:#75715e>/* 在这里调用了之前注册的handler_irq函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>            		init_ISA_irqs()
</span></span></span><span style=display:flex><span><span style=color:#75715e>            			-&gt; set_irq_chip_and_handler_name(i, &amp;i8259A_chip,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                              handle_level_irq, &#34;XT&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>							-&gt; __set_irq_handler(irq, handle, 0, name);
</span></span></span><span style=display:flex><span><span style=color:#75715e>								-&gt; desc-&gt;handle_irq = handle;
</span></span></span><span style=display:flex><span><span style=color:#75715e>                	即handle_level_irq
</span></span></span><span style=display:flex><span><span style=color:#75715e>                		-&gt; handle_IRQ_event(irq, action); 
</span></span></span><span style=display:flex><span><span style=color:#75715e>                			-&gt;  do {
</span></span></span><span style=display:flex><span><span style=color:#75715e>			                			ret = action-&gt;handler(irq, action-&gt;dev_id);
</span></span></span><span style=display:flex><span><span style=color:#75715e>            			    			action = action-&gt;next;
</span></span></span><span style=display:flex><span><span style=color:#75715e>        						} while (action);
</span></span></span><span style=display:flex><span><span style=color:#75715e>            	*/</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=注册中断>注册中断</h2><p>在Linux内核申请中断的函数是<code>request_irq()</code>,函数原型定义在<code>include/linux/interrupt.h</code>中，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>request_irq</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>irq_handler_t</span> handler, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev);
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	irq : 要申请的硬件中断号；
</span></span></span><span style=display:flex><span><span style=color:#75715e>	handler : 中断服务函数指针；
</span></span></span><span style=display:flex><span><span style=color:#75715e>	flags: 中断处理的属性，
</span></span></span><span style=display:flex><span><span style=color:#75715e>		若设置了IRQF_DISABLED则表示是快速中断，快速中断在处理过程中会屏蔽其他中断。
</span></span></span><span style=display:flex><span><span style=color:#75715e>		若设置了IRQD_SHARED则表示多个设备共享此中断。
</span></span></span><span style=display:flex><span><span style=color:#75715e>		若设置了IRQF_SAMPLE_RANDOM则表示对系统产生随机数有作用。
</span></span></span><span style=display:flex><span><span style=color:#75715e>		IRQF_TRIGGER_* 其中*可以是中断触发方式，定义在include/linux/interrupt.h中。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	name : 中断名字，/proc/interrupts文件系统中显示；
</span></span></span><span style=display:flex><span><span style=color:#75715e>	dev : 中断共享时可以用到，一般设置为这个设备的设备结构体或者NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e>	
</span></span></span><span style=display:flex><span><span style=color:#75715e>	返回值： 
</span></span></span><span style=display:flex><span><span style=color:#75715e>		0  : 成功 ； 
</span></span></span><span style=display:flex><span><span style=color:#75715e>		-INVAL : 表示中断号无效或处理函数指针为NULL ； 
</span></span></span><span style=display:flex><span><span style=color:#75715e>		-EBUSY : 表示中断已经被占用且不能共享。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><blockquote><p>关于request_irq()的最后一个参数dev</p><p>中断发生时，内核并不判断是共享中断线上的哪个设备产生了中断，它会循环执行所有该中断线上注册的所有中断服务函数（irqaction->handler函数）。因此irqaction->handler函数需要自己判断具体的中断源。很多资料都建议将设备结构指针作为此参数的值，当中断发生时，迅速根据硬件寄存器中的信息比照传入的dev参数判断是否是本设备发出的中断。而且free_irq()函数也需要据此判断从共享中断线上移除哪一个irqaction</p></blockquote><p>代码流程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*include/linux/interrupt.h*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> __must_check
</span></span><span style=display:flex><span><span style=color:#a6e22e>request_irq</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>irq_handler_t</span> handler, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>request_threaded_irq</span>(irq, handler, NULL, flags, name, dev);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exit_irq_thread</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> __must_check
</span></span><span style=display:flex><span><span style=color:#a6e22e>request_irq</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>irq_handler_t</span> handler, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev);
</span></span></code></pre></div><p>主要调用了<code>request_threaded_irq()</code>函数，此函数定义在<code>kernel/irq/manage.c</code>中，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      request_threaded_irq - allocate an interrupt line
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @irq: Interrupt line to allocate
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @handler: Function to be called when the IRQ occurs.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                Primary handler for threaded interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @thread_fn: Function called from the irq handler thread
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                  If NULL, no irq thread is created
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @irqflags: Interrupt type flags
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @devname: An ascii name for the claiming device
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @dev_id: A cookie passed back to the handler function
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      This call allocates interrupt resources and enables the
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      interrupt line and IRQ handling. From the point this
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      call is made your handler function may be invoked. Since
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      your handler function must clear any interrupt the board
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      raises, you must take care both to initialise your hardware
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      and to set up the interrupt handler in the right order.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      If you want to set up a threaded irq handler for your device
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      then you need to supply @handler and @thread_fn. @handler ist
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      still called in hard interrupt context and has to check
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      whether the interrupt originates from the device. If yes it
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      needs to disable the interrupt on the device and return
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      IRQ_THREAD_WAKE which will wake up the handler thread and run
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      @thread_fn. This split handler design is necessary to support
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      shared interrupts.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      Dev_id must be globally unique. Normally the address of the
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      device data structure is used as the cookie. Since the handler
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      receives this value it makes sense to use it.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      If your interrupt is shared you must pass a non NULL dev_id
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      as this is required when freeing the interrupt.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      Flags:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      IRQF_SHARED             Interrupt is shared
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      IRQF_DISABLED   Disable local interrupts while processing
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      IRQF_SAMPLE_RANDOM      The interrupt can be used for entropy
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      IRQF_TRIGGER_*          Specify active edge(s) or level
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>request_threaded_irq</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>irq_handler_t</span> handler,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>irq_handler_t</span> thread_fn, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> irqflags,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>devname, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irqaction <span style=color:#f92672>*</span>action;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span>desc;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> retval;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * handle_IRQ_event() always ignores IRQF_DISABLED except for
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * the _first_ irqaction (sigh).  That can cause oopsing, but
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * the behavior is classified as &#34;will not fix&#34; so we need to
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * start nudging drivers away from using that idiom.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((irqflags <span style=color:#f92672>&amp;</span> (IRQF_SHARED<span style=color:#f92672>|</span>IRQF_DISABLED)) <span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>                                        (IRQF_SHARED<span style=color:#f92672>|</span>IRQF_DISABLED)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pr_warning</span>(
</span></span><span style=display:flex><span>                  <span style=color:#e6db74>&#34;IRQ %d/%s: IRQF_DISABLED is not guaranteed on shared IRQs</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                        irq, devname);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>/*省略一些状态检查的代码*/</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        desc <span style=color:#f92672>=</span> <span style=color:#a6e22e>irq_to_desc</span>(irq);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>desc)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EINVAL;
</span></span><span style=display:flex><span>        action <span style=color:#f92672>=</span> <span style=color:#a6e22e>kzalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> irqaction), GFP_KERNEL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>action)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        action<span style=color:#f92672>-&gt;</span>handler <span style=color:#f92672>=</span> handler; <span style=color:#75715e>/* 注册中断服务函数 */</span>
</span></span><span style=display:flex><span>        action<span style=color:#f92672>-&gt;</span>thread_fn <span style=color:#f92672>=</span> thread_fn;
</span></span><span style=display:flex><span>        action<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>=</span> irqflags;
</span></span><span style=display:flex><span>        action<span style=color:#f92672>-&gt;</span>name <span style=color:#f92672>=</span> devname;
</span></span><span style=display:flex><span>        action<span style=color:#f92672>-&gt;</span>dev_id <span style=color:#f92672>=</span> dev_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        retval <span style=color:#f92672>=</span> <span style=color:#a6e22e>__setup_irq</span>(irq, desc, action);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (retval)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>kfree</span>(action);
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* 省略一部分 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> retval;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(request_threaded_irq);
</span></span></code></pre></div><p>首先从<code>irq</code>拿到<code>struct desc</code>，然后初始化了<code>struct desc</code>结构的<code>action</code>结构，最后调用了<code>__setup_irq()</code>函数。</p><p><code>__setup_irq()</code>函数还调用了内核线程的创建<code>kthread_create()</code>等等，暂时不做分析。</p><h2 id=中断处理流程>中断处理流程</h2><p>注册流程：</p><ul><li>系统初始化时 : 调用<code>init_IRQ()</code>， 此函数间接调用<code>init_ISA_irq()</code>函数，初始化<code>PIC</code>以及<code>struct irq_desc</code>数组，填充了<code>struct irq_desc</code>元素的<code>handler_irq</code>和<code>chip</code>结构。之后调用<code>set_intr_gate()</code>将<code>interrupts</code>数组设置到系统的<code>IDT</code>中。</li><li>在内核代码中调用<code>request_irq()</code>函数，将中断服务程序注册到<code>irqaction</code>结构中，调用<code>__setup_irq()</code>函数。</li></ul><p>中断发生时：先去IDT表中找到相应的中断门描述符，根据中断门描述符找到GDTR中相应的代码段，再根据中断门描述符中代码偏移，到相应代码段中找到中断服务程序入口，即<code>common_interrupt</code>，此函数先保存现场，然后将中断号压入栈，调用<code>do_IRQ()</code>函数，此函数调用<code>desc->handle_irq</code>即<code>handle_level_irq</code>，又调用了<code>handle_IRQ_event()</code>，此函数中循环调用<code>action->handler()</code>，间接调用到<code>request_irq()</code>函数注册的回调函数。</p><h2 id=小结>小结</h2><p>本文主要基于x86平台对应<code>linux 2.6.30.4</code>版本的内核源码，对<code>linux</code>中断的初始化过程进行简单分析。还有一些东西没有弄懂，留待以后分析。</p><ul><li><code>__setup_irq()</code>函数；</li><li>中断发生时代码执行到<code>action->handler()</code>的过程；</li><li><code>free_irq()</code>的执行流程；</li><li>从中断中返回；</li><li>软中断及<code>tasklet</code>；</li><li>一些其他细节；</li></ul><h2 id=a-id参考参考a>参考</h2><p><a href=http://home.ustc.edu.cn/~hchunhui/linux_intr.html>x86体系结构下Linux-2.6.26的中断处理</a></p><p><a href=https://blog.csdn.net/farmwang/article/details/52318573>中断之中断向量表IDT的初始化</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Yuanye Ma</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-04-15</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a href=https://github.com/gohugoio/hugoBasicExample rel=noopener target=_blank>See origin</a></span></p></div><footer class=post-footer><div class=post-tags><a href=http://0.0.0.0:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div><nav class=post-nav><a class=prev href=/post/os/linux-kernel/2020-10-08-vim-ctags-cscope/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i><span class="prev-text nav-default">vim ctags cscope</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/os/x86%E5%B9%B3%E5%8F%B0linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/><span class="next-text nav-default">x86平台linux系统调用分析</span>
<span class="prev-text nav-mobile">Next</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div><nav class=toc id=toc><div class=toc-title>Table of Contents</div><div class="toc-content custom-scrollbar"><nav id=TableOfContents><ul><li><a href=#基础知识>基础知识</a><ul><li><a href=#关于io-apic的一些更详细的资料>关于I/O APIC的一些更详细的资料</a></li></ul></li><li><a href=#基本数据结构>基本数据结构</a><ul><li><a href=#irq_desc_t>irq_desc_t</a></li><li><a href=#irq_chip>irq_chip</a></li><li><a href=#irqaction>irqaction</a></li></ul></li><li><a href=#中断初始化>中断初始化</a><ul><li><a href=#idt初步初始化><code>IDT</code>初步初始化</a></li><li><a href=#idt最终初始化><code>IDT</code>最终初始化</a></li><li><a href=#trap_init><code>trap_init()</code></a></li><li><a href=#early_irq_init><code>early_irq_init()</code></a></li><li><a href=#init_irq><code>init_IRQ()</code></a></li></ul></li><li><a href=#注册中断>注册中断</a></li><li><a href=#中断处理流程>中断处理流程</a></li><li><a href=#小结>小结</a></li><li><a href=#a-id参考参考a>参考</a></li></ul></nav></div></nav></div></main><footer id=footer class=footer><div class=icon-links><a href=yuanye.ma@qq.com rel="me noopener" class=iconfont title=email target=_blank><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a><a href=https://github.com/YuanyeMa rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" style="" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg>
</a><a href=https://www.zhihu.com/people/mr-kevin-92 rel="me noopener" class=iconfont title=zhihu target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z"/></svg>
</a><a href="https://space.bilibili.com/159072924?spm_id_from=333.1007.0.0" rel="me noopener" class=iconfont title=bilibili target=_blank><svg class="icon" style="" viewBox="0 0 1024 1024" width="36" height="36" id="svg8"><path style="" d="M744.60599.00486267A41.779915 41.779915.0 00710.4184 18.673394L548.5048 255.32642h-11.70046a41.779915 41.779915.0 00-10.80295-7.84928L235.66 97.084498a41.779915 41.779915.0 00-20.07193-4.960864 41.779915 41.779915.0 00-18.3748 79.145436L359.4859 255.32642H128.16909c-49.458302.0-89.27932 39.82105-89.27932 89.27932v508.65224c0 49.4583 39.821018 89.27934 89.27932 89.27934h19.48445C149.12802 984.5043 179.92773 1024 224.79179 1024c44.86407.0 75.66379-39.4957 77.13826-81.46268H719.98116C721.45559 984.5043 752.25533 1024 797.1194 1024c44.86406.0 75.6638-39.4957 77.13824-81.46268h21.57323c49.45831.0 89.27936-39.82104 89.27936-89.27934V344.60574c0-49.45827-39.82105-89.27932-89.27936-89.27932H649.74567L779.38103 65.866924A41.779915 41.779915.0 00744.60599.00486267zM644.49108 418.70871c6.29985.21538 12.44451 2.01107 17.86888 5.22196l171.36218 98.10771c18.23417 10.21935 24.63334 33.34627 14.24614 51.48533-10.38726 18.13909-33.57344 24.32718-51.61587 13.77296L624.9903 489.18895c-15.21356-8.41858-22.66871-26.1765-18.03211-42.93436 4.63664-16.75784 20.15573-28.14465 37.53289-27.54588zM350.2006 432.31846c16.89952.0317 31.69582 11.33328 36.17844 27.62747 4.48262 16.2942-2.44981 33.57765-16.95507 42.24898l-140.7157 86.91312c-17.68528 11.18244-41.09629 5.77692-52.08912-12.02686-10.99282-17.80373-5.33855-41.15658 12.58167-51.95857L329.9002 438.2095c6.0643-3.86439 13.10951-5.90891 20.3004-5.89104zM501.605 641.53985c3.75002-.15248 7.48645.53903 10.93349 2.0235.15842.0637.31618.12888.47325.19582.59328.27092 1.17574.56489 1.74609.88121.15868.0854.31643.17233.47325.2611.55694.32165 1.10131.66458 1.63185 1.02807.16455.1123.32777.2265.48956.34269.50382.36781.99371.75428 1.46868 1.15864.18724.15504.37218.31282.55484.47323.43271.38784.8518.79061 1.25653 1.20756.15449.16114.30679.32437.45693.48959.40798.44266.79989.89988 1.17494 1.37076.17799.22544.35205.45395.5222.68538.25932.34701.50964.70071.75064 1.06071.26712.39516.52286.79784.76699 1.20757.16907.29043.33231.58424.48957.88123.21836.41297.42513.83199.62009 1.25653.14836.32333.28983.64976.42429.97911.21319.51552.40915 1.03801.58747 1.5666.0677.19499.13296.39085.19582.58748.18652.60823.34984 1.22334.48957 1.84399.0397.16277.0779.32601.11423.48957.1436.69112.25788 1.38801.34269 2.08877.005.0381.0111.0761.0163.11424.0857.78056.13474 1.56471.14687 2.34988.005.0543.0111.10879.0163.1632.0.0-.008 1.12132.0 1.45234.0.0-.14697 17.84761 5.89102 34.12231 3.01902 8.13734 7.33278 15.10615 12.61433 19.61501 5.28157 4.50889 11.42894 7.62081 23.64572 7.62081 12.2168.0 18.36416-3.11192 23.64573-7.62081 5.28154-4.50886 9.5953-11.47767 12.6143-19.61501 6.03799-16.2747 5.89103-34.12231 5.89103-34.12231-.44885-13.87045 10.45922-25.46302 24.3311-25.86506 13.87189-.40201 25.42828 10.53953 25.78348 24.41272.0.0 1.11929 25.7226-9.00791 53.01927-5.06359 13.64832-13.1986 28.46036-27.05631 40.29073-13.85772 11.83039-33.5454 19.63135-56.20142 19.63135-22.65603.0-42.34371-7.80096-56.20141-19.63135-4.1801-3.56856-7.78733-7.42433-10.99878-11.42303-3.21235 4.00037-6.81703 7.85309-10.99876 11.42303-13.85773 11.83039-33.5454 19.63135-56.20144 19.63135-22.65601.0-42.3437-7.80096-56.2014-19.63135-13.85775-11.83037-21.99272-26.64241-27.05632-40.29073-10.12725-27.29667-9.00789-53.01928-9.00789-53.01927.20714-13.83687 11.58744-24.88848 25.42444-24.69013 14.1263.19991 25.2971 12.0278 24.69011 26.14247.0.0-.14697 17.84761 5.89103 34.12231 3.01902 8.13734 7.31646 15.10615 12.598 19.61501 5.28155 4.50889 11.44526 7.62081 23.66203 7.62081 12.21681.0 18.36418-3.11192 23.64573-7.62081 5.28154-4.50886 9.57899-11.47767 12.598-19.61501 5.76352-15.53489 5.89112-32.05691 5.89103-33.56746.006-.37466.0111-1.05336.0163-1.20759-.0117-.74583.0105-1.49177.0652-2.23565.009-.15784.0204-.31561.0327-.47324.14204-1.56859.43163-3.12027.86487-4.63449.0213-.0763.0433-.15244.0652-.22848 3.0335-10.25748 12.24157-17.46007 22.92769-17.93417z" id="rect824"/></svg>
</a><a href=http://0.0.0.0:1313/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span><span class=copyright-year>&copy;
2024
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i></span><span class=author>Yuanye Ma</span></span></div></footer><div class=button__back-to-top><a href=#back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></a></div></div><script type=text/javascript src=/lib/jquery/jquery-3.7.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/js/main.1f1ab71292e8ae0addbb90a5827f619e1cc7eba4a57b08930f33e5d8700d84be.js integrity="sha256-Hxq3EpLorgrdu5Clgn9hnhzH66SlewiTDzPl2HANhL4=" crossorigin=anonymous></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>