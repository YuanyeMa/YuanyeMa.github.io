<!DOCTYPE html>
<html
  lang="en"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          Linux 内核内存管理 - Yuanye Ma&#39;s Blog
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Yuanye Ma" />
  <meta name="description" content="0xFFtypora-copy-images-to: ./ Linux 内核内存管理 [toc] 越整理发现知识越多，分页机制、伙伴算法、slab等任何一块单独拿出来都有很多东西，因此本文先粗略的统揽全貌，有时间再针对" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.125.4" />


<link rel="canonical" href="http://0.0.0.0:1313/post/os/linux-kernel/linux-kernel%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/linux-%E5%86%85%E6%A0%B8%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.e826e860368147e5a6685e686355e4d7789023c18c9ea2e78b35f6786ce92736.css" integrity="sha256-6CboYDaBR&#43;WmaF5oY1Xk13iQI8GMnqLnizX2eGzpJzY=" media="screen" crossorigin="anonymous">







<meta property="og:url" content="http://0.0.0.0:1313/post/os/linux-kernel/linux-kernel%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/linux-%E5%86%85%E6%A0%B8%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">
  <meta property="og:site_name" content="Yuanye Ma&#39;s Blog">
  <meta property="og:title" content="Linux 内核内存管理">
  <meta property="og:description" content="0xFFtypora-copy-images-to: ./ Linux 内核内存管理 [toc] 越整理发现知识越多，分页机制、伙伴算法、slab等任何一块单独拿出来都有很多东西，因此本文先粗略的统揽全貌，有时间再针对">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2019-04-15T16:01:23+08:00">
    <meta property="article:modified_time" content="2019-04-15T16:01:23+08:00">
    <meta property="article:tag" content="Kernel Memory Manager">

  <meta itemprop="name" content="Linux 内核内存管理">
  <meta itemprop="description" content="0xFFtypora-copy-images-to: ./ Linux 内核内存管理 [toc] 越整理发现知识越多，分页机制、伙伴算法、slab等任何一块单独拿出来都有很多东西，因此本文先粗略的统揽全貌，有时间再针对">
  <meta itemprop="datePublished" content="2019-04-15T16:01:23+08:00">
  <meta itemprop="dateModified" content="2019-04-15T16:01:23+08:00">
  <meta itemprop="wordCount" content="11652">
  <meta itemprop="keywords" content="Kernel Memory Manager"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux 内核内存管理">
<meta name="twitter:description" content="0xFFtypora-copy-images-to: ./ Linux 内核内存管理 [toc] 越整理发现知识越多，分页机制、伙伴算法、slab等任何一块单独拿出来都有很多东西，因此本文先粗略的统揽全貌，有时间再针对">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">功不唐捐</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    

    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      功不唐捐
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://0.0.0.0:1313/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">Linux 内核内存管理</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      <a href="/about">
        <span class="post-meta-author-name">
          Yuanye Ma
        </span>
      </a>
    
  </div>

  <div class="post-meta-time">
    <time datetime="2019-04-15">
      2019-04-15
    </time>
  </div>

  


  <div class="post-meta__right">
    

    <div class="post-meta-category">
        <a href="http://0.0.0.0:1313/categories/linux-kernel/"> Linux Kernel </a>
          
      </div>


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <hr>
<h2 id="0xfftypora-copy-images-to-">0xFFtypora-copy-images-to: ./</h2>
<h1 id="linux-内核内存管理">Linux 内核内存管理</h1>
<p>[toc]</p>
<p>越整理发现知识越多，分页机制、伙伴算法、slab等任何一块单独拿出来都有很多东西，因此本文先粗略的统揽全貌，有时间再针对每个部分，逐个深入，单独分析梳理成文章。</p>
<h2 id="内存寻址的基本框架">内存寻址的基本框架</h2>
<p>​	Linux内核的映射机制分三层：页面目录：<code>PGD</code>, 中间目录：<code>PMD</code>， 页表<code>PT</code>。<code>PT</code>的表项称为<code>PTE (Page Table Entry)</code>.  <code>PGD</code>  <code>PMD</code>以及<code>PT</code>三者都是数组。三者的关系如图所示。</p>
<p><img alt="image-20201209084314672" src="image-20201209084314672.png"></p>
<p>CPU给出的线性地址在逻辑上可以分为4个位段，各占若干位。分别用作在页面目录表<code>PGD</code>中的下标志，页中间目录表<code>PMD</code>中的下标，页表<code>PT</code>中的下标，以及物理页内的地址偏移。线性地址映射为物理地址的大致过程如下。</p>
<ol>
<li>CPU发出线性地址；</li>
<li>用1中线性地址的最高位段中的值，在<code>PGD</code>中找到相应的表项，该表项的内容指向<code>PMD</code>的地址；</li>
<li>用1中线性地址的第二个位段中的值，在<code>PMD</code>中找到相应的表项，该表项的内容指向<code>PT</code>的地址；</li>
<li>用1中线性地址的第三个位段中的值，在<code>PT</code>中找到相应的表项，该表项是<code>PTE</code>,即存储物理页面的地址。</li>
<li>在4中找到的物理页中，以1中线性地址的最后一个位段的内容作为地址偏移量，找到对应的物理地址。</li>
</ol>
<p>i386的MMU只支持两级页表，对于Pentium Pro开始Intel引入了物理地址扩充功能<code>PAE</code>，允许将32位的地址线扩展为36位，并在硬件上支持了三层映射。两层映射、三层映射甚至64位机器的四层映射，原理都是相似的，力图简单，先搞懂两层映射。</p>
<p><code>arch/x86/include/asm/pgtable_32_types.h</code>中的宏<code>CONFIG_X86_PAE</code>在内核配置的过程中(<code>arch/x86/Kconfig</code>中)生成，决定是否开启<code>PAE</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable_32_types.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The Linux x86 paging architecture is &#39;compile-time dual-mode&#39;, it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * implements both the traditional 2-level x86 page tables and the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * newer 3-level PAE-mode page tables.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_X86_PAE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># include &lt;asm/pgtable-3level_types.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># define PMD_SIZE       (1UL &lt;&lt; PMD_SHIFT)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># define PMD_MASK       (~(PMD_SIZE - 1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># include &lt;asm/pgtable-2level_types.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>不开启<code>PAE</code>时即包含<code>&lt;asm/pgtable-2level_types.h&gt;</code>头文件，即采用两级页表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable-2level_types.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * traditional i386 two-level paging structure:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PGDIR_SHIFT     22   </span><span style="color:#75715e">/* 表示线性地址中PGD下标位段在线性地址中的起始位置，即从bit22开始到bit31共10位 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PTRS_PER_PGD    1024 </span><span style="color:#75715e">/* 代表每个PGD表中指针个数 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable_32_types.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PGDIR_SIZE      (1UL &lt;&lt; PGDIR_SHIFT) </span><span style="color:#75715e">/* 表示PGD中每一个表代表1x2^22的地址空间 */</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>默认状态下，32位的地址空间分为 <code>0x00000000 - 0xBFFFFFFF</code> 3G的用户态空间，和<code>0xC0000000 - 0xFFFFFFFF</code> 1G的内核态空间。下边的配置项决定内核空间的开始位置，默认是从<code>0xC0000000</code>开始的1G空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/Kconfig */</span>
</span></span><span style="display:flex;"><span>config PAGE_OFFSET
</span></span><span style="display:flex;"><span>        hex
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0xB0000000</span> <span style="color:#66d9ef">if</span> VMSPLIT_3G_OPT
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0x80000000</span> <span style="color:#66d9ef">if</span> VMSPLIT_2G
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0x78000000</span> <span style="color:#66d9ef">if</span> VMSPLIT_2G_OPT
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0x40000000</span> <span style="color:#66d9ef">if</span> VMSPLIT_1G
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0xC0000000</span>
</span></span><span style="display:flex;"><span>        depends on X86_32
</span></span></code></pre></div><p>关于<code>PAGE_OFFSET</code>宏的定义如下过程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/page_types.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PAGE_OFFSET             ((unsigned long)__PAGE_OFFSET)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 其中__PAGE_OFFSET定义在 arch/x86/include/asm/page_32_types.h*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This handles the memory map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * A __PAGE_OFFSET of 0xC0000000 means that the kernel has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * a virtual address space of one gigabyte, which limits the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * amount of physical memory you can use to about 950MB.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * If you want more physical memory than this then see the CONFIG_HIGHMEM4G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * and CONFIG_HIGHMEM64G options in the kernel configuration.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __PAGE_OFFSET           _AC(CONFIG_PAGE_OFFSET, UL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* CONFIG_PAGE_OFFSET 由前边arch/x86/Kconfig中的配置项PAGE_OFFSET决定 */</span>
</span></span></code></pre></div><p>由此原理内核定义了一套用于内核空间中简单的地址转换方式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/page.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __pa(x)         __phys_addr((unsigned long)(x))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __va(x)                 ((void *)((unsigned long)(x)+PAGE_OFFSET))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*arch/x86/include/asm/page_32.h*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __phys_addr_nodebug(x)  ((x) - PAGE_OFFSET)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __phys_addr(x)          __phys_addr_nodebug(x)
</span></span></span></code></pre></div><h2 id="地址映射全过程">地址映射全过程</h2>
<p>假设hello-world程序编译链接加载完的程序入口地址是<code>0x08048568</code>，CPU要执行此程序，首先此地址经过<code>MMU</code>得到对应的物理地址，将<code>CS:EIP</code>的地址指向该物理地址，之后CPU就可以运行此程序的代码。</p>
<p>首先看一下段式映射机制，即得到物理地址后CPU怎么执行。</p>
<h3 id="段式映射机制">段式映射机制</h3>
<p><img alt="image-20201209091927275" src="image-20201209091927275.png"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/processor.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> new_ip,
</span></span><span style="display:flex;"><span>                                               <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> new_sp);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* /arch/x86/kernel/process_32.c */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">start_thread</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> new_ip, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> new_sp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">set_user_gs</span>(regs, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>fs                <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">set_fs</span>(USER_DS);
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>ds                <span style="color:#f92672">=</span> __USER_DS;
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>es                <span style="color:#f92672">=</span> __USER_DS;
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>ss                <span style="color:#f92672">=</span> __USER_DS;
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>cs                <span style="color:#f92672">=</span> __USER_CS;
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>ip                <span style="color:#f92672">=</span> new_ip;
</span></span><span style="display:flex;"><span>        regs<span style="color:#f92672">-&gt;</span>sp                <span style="color:#f92672">=</span> new_sp;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Free the old FP and other extended state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free_thread_xstate</span>(current);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(start_thread);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* /arch/x86/include/asm/segment.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __KERNEL_CS     (GDT_ENTRY_KERNEL_CS * 8) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>								<span style="color:#75715e">/*(12+0)*8=96 : 60H :	0000 0000 0110 0000*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __KERNEL_DS     (GDT_ENTRY_KERNEL_DS * 8) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>								<span style="color:#75715e">/*(12+1)*8=104 : 68H :	0000 0000 0110 1000*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __USER_DS     (GDT_ENTRY_DEFAULT_USER_DS* 8 + 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>								<span style="color:#75715e">/* 15*8+3=123 : 7BH :	0000 0000 0111 1011*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __USER_CS     (GDT_ENTRY_DEFAULT_USER_CS* 8 + 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>								<span style="color:#75715e">/* 14*8+3=115 : 73H :	0000 0000 0111 0011*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_KERNEL_BASE   12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_KERNEL_CS             (GDT_ENTRY_KERNEL_BASE + 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_KERNEL_DS             (GDT_ENTRY_KERNEL_BASE + 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_DEFAULT_USER_CS       14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_DEFAULT_USER_DS       15
</span></span></span></code></pre></div><p>对应到段寄存器格式定义可得下边的表，即四个段全在<code>GDT</code>中。</p>
<table>
<thead>
<tr>
<th></th>
<th>index</th>
<th>TI</th>
<th>RPL</th>
</tr>
</thead>
<tbody>
<tr>
<td>__KERNEL_CS</td>
<td>12</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>__KERNEL_DS</td>
<td>13</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>__USER_DS</td>
<td>15</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>__USER_CS</td>
<td>14</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>内核<code>GDT</code>表的映像在<code>arch/x86/include/asm/segment.h</code>的注释可以看出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The layout of the per-CPU GDT under Linux:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   0 - null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   1 - reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   2 - reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   3 - reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   4 - unused                 &lt;==== new cacheline
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   5 - unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  ------- start of TLS (Thread-Local Storage) segments:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   6 - TLS segment #1                 [ glibc&#39;s TLS segment ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   7 - TLS segment #2                 [ Wine&#39;s %fs Win32 segment ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   8 - TLS segment #3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   9 - reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  10 - reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  11 - reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  ------- start of kernel segments:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  12 - kernel code segment            &lt;==== new cacheline
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  13 - kernel data segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  14 - default user CS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  15 - default user DS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  16 - TSS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  17 - LDT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  18 - PNPBIOS support (16-&gt;32 gate)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  19 - PNPBIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  20 - PNPBIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  21 - PNPBIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  22 - PNPBIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  23 - APM BIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  24 - APM BIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  25 - APM BIOS support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  26 - ESPFIX small SS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  27 - per-cpu                        [ offset to per-cpu data area ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  28 - stack_canary-20                [ for stack protector ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  29 - unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  30 - unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  31 - TSS for double fault handler
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Constructor for a conventional segment GDT (or LDT) entry */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* This is a macro so it can be used in initializers */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY(flags, base, limit)                   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        ((((base)  &amp; 0xff000000ULL) &lt;&lt; (56-24)) |       \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         (((flags) &amp; 0x0000f0ffULL) &lt;&lt; 40) |            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         (((limit) &amp; 0x000f0000ULL) &lt;&lt; (48-16)) |       \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         (((base)  &amp; 0x00ffffffULL) &lt;&lt; 16) |            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         (((limit) &amp; 0x0000ffffULL)))
</span></span></span></code></pre></div><p>关于<code>gdt</code>的建立过程，在内核的初始化阶段完成，搜索内核代码发现在<code>arch/x86/kernel/cpu/common.c</code>定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">DEFINE_PER_CPU_PAGE_ALIGNED</span>(<span style="color:#66d9ef">struct</span> gdt_page, gdt_page) <span style="color:#f92672">=</span> { .gdt <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 省略其他 */</span>
</span></span><span style="display:flex;"><span> [GDT_ENTRY_KERNEL_CS]           <span style="color:#f92672">=</span> { { { <span style="color:#ae81ff">0x0000ffff</span>, <span style="color:#ae81ff">0x00cf9a00</span> } } },
</span></span><span style="display:flex;"><span> [GDT_ENTRY_KERNEL_DS]           <span style="color:#f92672">=</span> { { { <span style="color:#ae81ff">0x0000ffff</span>, <span style="color:#ae81ff">0x00cf9200</span> } } },
</span></span><span style="display:flex;"><span> [GDT_ENTRY_DEFAULT_USER_CS]     <span style="color:#f92672">=</span> { { { <span style="color:#ae81ff">0x0000ffff</span>, <span style="color:#ae81ff">0x00cffa00</span> } } },
</span></span><span style="display:flex;"><span> [GDT_ENTRY_DEFAULT_USER_DS]     <span style="color:#f92672">=</span> { { { <span style="color:#ae81ff">0x0000ffff</span>, <span style="color:#ae81ff">0x00cff200</span> } } },
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*省略其他*/</span>
</span></span><span style="display:flex;"><span>} };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_PER_CPU_SYMBOL_GPL</span>(gdt_page);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	GDT_ENTRY_KERNEL_CS = 12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	GDT_ENTRY_KERNEL_DS = 13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	GDT_ENTRY_DEFAULT_USER_CS = 14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	GDT_ENTRY_DEFAULT_USER_DS = 15
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	这里还有一点需要注意
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	{ 0x0000ffff, 0x00cf9a00 }在内存中应该是0x00cf9a000000ffff
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*include/linux/percpu-defs.h&#34; */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEFINE_PER_CPU_PAGE_ALIGNED(type, name)                         \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        DEFINE_PER_CPU_SECTION(type, name, &#34;.page_aligned&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*include/linux/percpu-defs.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEFINE_PER_CPU_SECTION(type, name, section)                     \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        __attribute__((__section__(PER_CPU_BASE_SECTION section)))      \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        PER_CPU_ATTRIBUTES PER_CPU_DEF_ATTRIBUTES                       \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        __typeof__(type) per_cpu__##name
</span></span></span></code></pre></div><p><img alt="image-20201209100428575" src="image-20201209100428575.png"></p>
<p>参照<code>gdt</code>表项定义可以得出以下结论</p>
<table>
<thead>
<tr>
<th></th>
<th>B31-B24</th>
<th></th>
<th>L19-L16</th>
<th></th>
<th>B23-B16</th>
<th>B15-B0</th>
<th>L15-L0</th>
</tr>
</thead>
<tbody>
<tr>
<td>__KERNEL_CS</td>
<td>0x00</td>
<td>0xC</td>
<td>0xF</td>
<td>0x9A</td>
<td>0x00</td>
<td>0x0000</td>
<td>0xFFFF</td>
</tr>
<tr>
<td>__KERNEL_DS</td>
<td>0x00</td>
<td>0xC</td>
<td>0xF</td>
<td>0x92</td>
<td>0xFF</td>
<td>0x00CF</td>
<td>0xFFFF</td>
</tr>
<tr>
<td>__USER_CS</td>
<td>0x00</td>
<td>0xC</td>
<td>0xF</td>
<td>0xFA</td>
<td>0xFF</td>
<td>0x00CF</td>
<td>0xFFFF</td>
</tr>
<tr>
<td>__USER_DS</td>
<td>0x00</td>
<td>0xC</td>
<td>0xF</td>
<td>0xF2</td>
<td>0xFF</td>
<td>0x00CF</td>
<td>0xFFFF</td>
</tr>
</tbody>
</table>
<p>即</p>
<ul>
<li>B0-B15, B16-B24 全是0， 段的基地址是0；</li>
<li>L0-L15， L16-L19 全是1， 段的上限是0xFFFFF;</li>
<li>G位都是1， 段长单位都为4KB；</li>
<li>D/B位都为1，对四个段访问的指令都是32位的；</li>
<li>P位都为1，四个段都在内存中；</li>
<li>bit40-bit46字段有区别
<ul>
<li>__KERNEL_CS ： DPL = 0； S = 1代码或数据段；101 代码段，可读；未被访问过；</li>
<li>__KERNEL_DS ： DPL = 0； S = 1代码或数据段；001 数据段，可读，可写；未被访问过；</li>
<li>__USER_CS ： DPL = 3； S = 1代码或数据段；101 代码段，可读；未被访问过；</li>
<li>__USER_DS ： DPL = 3； S = 1代码或数据段；001 数据段，可读，可写；未被访问过；</li>
</ul>
</li>
</ul>
<p>小结</p>
<p>​	分段机制中，所有进程公用一个<code>GDT</code>，主要分了四个段：内核代码段、内核数据段、用户代码段、用户数据段，所有进程共享这四个段。这四个段的映射整个内存空间。</p>
<h3 id="页式映射机制">页式映射机制</h3>
<p>分页机制主要完成虚拟地址（线性地址）到物理地址的映射。</p>
<p>分页机制中，每个进程都有其自己的页目录<code>PGD</code>，指向这个目录的指针保存在每个进程的<code>mm_struct</code>结构中，每当调度一个进程进入运行时，内核都据此设置<code>CR3</code>寄存器，<code>MMU</code>的硬件又从<code>CR3</code>中取得<code>PGD</code>的地址。</p>
<p>CPU给出线性地址<code>0x08048568</code>，写成二进制形式<code>0000 1000 0000 0100 1000 0101 0110 1000</code>。</p>
<ul>
<li>查<code>PGD</code>： <code>0000 1000 00</code>十进制为32，以32位为下标，在<code>PGD</code>中找到相应表项，取此表项的高20位后边补12个0组成<code>PT</code>的地址。</li>
<li>查<code>PT</code> : <code>00 0100 1000</code> 十进制为72，以72位下标，在<code>PT</code>中找到相应的表项，取此表项的高20位后边补12个0，组成页表的地址。</li>
<li>查页表：线性地址中省下的12位<code> 0101 0110 1000</code>为地址偏移，上一步查到的页表地址加上此偏移，得到线性地址<code>0x08048568</code>相应的物理地址。</li>
</ul>
<p>此过程中共访存了3次，第一次取<code>PGD[32]</code>，第二次取<code>PT[72]</code>，第三次取<code>PT[72]+0101 0110 1000</code>得到物理地址。</p>
<p>时间优化： 快表 <code>TLB</code>;</p>
<p>空间优化： 多级页表。</p>
<hr>
<p>内核启动过程和启动完成后<code>gdt</code>有所不同，以下为内核启动时<code>gdt</code>的初始化函数调用过程。</p>
<p>参考<a href="https://blog.csdn.net/baidu_31504167/article/details/100525791">这篇文章</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>arch<span style="color:#f92672">/</span>x86<span style="color:#f92672">/</span>boot<span style="color:#f92672">/</span>main.c <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> arch<span style="color:#f92672">/</span>x86<span style="color:#f92672">/</span>boot<span style="color:#f92672">/</span>pm.c : <span style="color:#a6e22e">go_to_protected_mode</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">-&gt;</span> arch<span style="color:#f92672">/</span>x86<span style="color:#f92672">/</span>boot<span style="color:#f92672">/</span>pm.c : <span style="color:#a6e22e">setup_gdt</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup_gdt</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* There are machines which are known to not boot with the GDT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           being 8-byte unaligned.  Intel recommends 16 byte alignment. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> u64 boot_gdt[] <span style="color:#a6e22e">__attribute__</span>((<span style="color:#a6e22e">aligned</span>(<span style="color:#ae81ff">16</span>))) <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* CS: code, read/execute, 4 GB, base 0 */</span>
</span></span><span style="display:flex;"><span>                [GDT_ENTRY_BOOT_CS] <span style="color:#f92672">=</span> <span style="color:#a6e22e">GDT_ENTRY</span>(<span style="color:#ae81ff">0xc09b</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0xfffff</span>),
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* DS: data, read/write, 4 GB, base 0 */</span>
</span></span><span style="display:flex;"><span>                [GDT_ENTRY_BOOT_DS] <span style="color:#f92672">=</span> <span style="color:#a6e22e">GDT_ENTRY</span>(<span style="color:#ae81ff">0xc093</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0xfffff</span>),
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* TSS: 32-bit tss, 104 bytes, base 4096 */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* We only have a TSS here to keep Intel VT happy;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                   we don&#39;t actually use it for anything. */</span>
</span></span><span style="display:flex;"><span>                [GDT_ENTRY_BOOT_TSS] <span style="color:#f92672">=</span> <span style="color:#a6e22e">GDT_ENTRY</span>(<span style="color:#ae81ff">0x0089</span>, <span style="color:#ae81ff">4096</span>, <span style="color:#ae81ff">103</span>),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Xen HVM incorrectly stores a pointer to the gdt_ptr, instead
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           of the gdt_ptr contents.  Thus, make it static so it will
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           stay in memory, at least long enough that we switch to the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           proper kernel GDT. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> gdt_ptr gdt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        gdt.len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(boot_gdt)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        gdt.ptr <span style="color:#f92672">=</span> (u32)<span style="color:#f92672">&amp;</span>boot_gdt <span style="color:#f92672">+</span> (<span style="color:#a6e22e">ds</span>() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;lgdtl %0&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;m&#34;</span> (gdt));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_BOOT_CS       2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GDT_ENTRY_BOOT_DS       (GDT_ENTRY_BOOT_CS + 1)
</span></span></span></code></pre></div><h2 id="几个重要的数据结构">几个重要的数据结构</h2>
<p>系统中的每个物理页面都有一个<code>page</code>结构，系统在初始化时根据系统中物理内存的大小建立起一个<code>page</code>结构数组，作为物理页面的“仓库”，里面每个<code>page</code>数据结构都代表系统中一个物理页面。</p>
<p>“仓库”中的物理页面被划分为<code>ZONE_DMA</code> 、 <code>ZONE_NORMAL</code>和<code>ZONE_HIGHMEM</code>区，其中<code>ZONE_HIGHMEM</code>用于物理地址超过1G的存储空间，在64位系统中该区为空。一个管理区用一个<code>zone_struct</code>结构表示。</p>
<p>对于NUMA结构，管理区不再是最高层级的存储管理机构，而是在每个存储节点中都至少有两个管理区，而且前述<code>page</code>结构数组，也不再是全局性的，而是从属于具体的节点。  <code>pg_data_t</code>结构保存节点信息。</p>
<h3 id="pgd_t--pmd_t--pte_t">pgd_t / pmd_t / pte_t</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable_types.h&#34; */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> { <span style="color:#66d9ef">pgdval_t</span> pgd; } <span style="color:#66d9ef">pgd_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if PAGETABLE_LEVELS &gt; 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> { <span style="color:#66d9ef">pmdval_t</span> pmd; } <span style="color:#66d9ef">pmd_t</span>; <span style="color:#75715e">/* 这里为了简单只看 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#esle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> { <span style="color:#66d9ef">pud_t</span> pud; } <span style="color:#66d9ef">pmd_t</span>; <span style="color:#75715e">//include/asm-generic/pgtable-nopmd.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable-2level_types.h */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>   <span style="color:#66d9ef">pteval_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>   <span style="color:#66d9ef">pmdval_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>   <span style="color:#66d9ef">pudval_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>   <span style="color:#66d9ef">pgdval_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>   <span style="color:#66d9ef">pgprotval_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pteval_t</span> pte;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pteval_t</span> pte_low;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">pte_t</span>;
</span></span></code></pre></div><p>页面目录<code>PGD</code>  中间目录<code>PMD</code> 页表<code>PT</code> 分别是由表项<code>pgd_t</code> <code>pmd_t</code> <code>pte_t</code>组成的数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable_types.h  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> pgprot { <span style="color:#66d9ef">pgprotval_t</span> pgprot; } <span style="color:#66d9ef">pgprot_t</span>; <span style="color:#75715e">//页面保护的结构
</span></span></span></code></pre></div><h3 id="struct-page"><code>struct page</code></h3>
<p>内核中有一个全局量<code>mem_map</code>（定义在mm/memory.c的70行<code>struct page *mem_map;</code>）是一个指针，指向一个<code>page</code>数据结构的数组，<strong>每个<code>page</code>代表着一个物理页面</strong>，整个数组就代表着系统中的全部物理页面。系统在初始化时根据物理内存的大小建立<code>mem_map</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* include/linux/mm_types.h +40 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Each physical page in the system has a struct page associated with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * it to keep track of whatever it is we are using the page for at the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * moment. Note that we have no way to track which tasks are using
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * a page, though if it is a pagecache page, rmap structures can tell us
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * who is mapping it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> page {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;            <span style="color:#75715e">/* Atomic flags, some possibly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                         * updated asynchronously */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">atomic_t</span> _count;                <span style="color:#75715e">/* Usage count, see below. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">atomic_t</span> _mapcount;     <span style="color:#75715e">/* Count of ptes mapped in mms,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                         * to show when page is mapped
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                         * &amp; limit reverse map searches.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                         */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">struct</span> {                <span style="color:#75715e">/* SLUB */</span>
</span></span><span style="display:flex;"><span>                        u16 inuse;
</span></span><span style="display:flex;"><span>                        u16 objects;
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> private;          <span style="color:#75715e">/* Mapping-private opaque data:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * usually used for buffer_heads
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * if PagePrivate set; used for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * swp_entry_t if PageSwapCache;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * indicates order in the buddy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * system if PG_buddy is set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">struct</span> address_space <span style="color:#f92672">*</span>mapping;  <span style="color:#75715e">/* If low bit clear, points to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * inode address_space, or NULL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * If page mapped as anonymous
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * memory, low bit is set, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * it points to anon_vma object:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * see PAGE_MAPPING_ANON below.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 */</span>
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if USE_SPLIT_PTLOCKS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">spinlock_t</span> ptl;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>slab;    <span style="color:#75715e">/* SLUB: Pointer to slab */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>first_page;    <span style="color:#75715e">/* Compound tail pages */</span>
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">pgoff_t</span> index;          <span style="color:#75715e">/* Our offset within mapping. */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>freelist;         <span style="color:#75715e">/* SLUB: freelist req. slab lock */</span>
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head lru;           <span style="color:#75715e">/* Pageout list, eg. active_list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                         * protected by zone-&gt;lru_lock !
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * On machines where all RAM is mapped into kernel address space,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * we can simply calculate the virtual address. On machines with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * highmem some memory is mapped into kernel virtual memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * dynamically, so we need a place to store that address.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Note that this field could be 16 bits on x86 ... ;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Architectures with slow multiplication can define
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * WANT_PAGE_VIRTUAL in asm/page.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(WANT_PAGE_VIRTUAL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>virtual;                  <span style="color:#75715e">/* Kernel virtual address (NULL if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                           not kmapped, ie. highmem) */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* WANT_PAGE_VIRTUAL */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_WANT_PAGE_DEBUG_FLAGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> debug_flags;      <span style="color:#75715e">/* Use atomic bitops on this */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>如果把物理内存看做一个物理页面的“数组”，高20位就是数组的下标，也就是物理页面的序号，用这个下标，可以在上述<code>page</code>结构数组中找到代表目标物理页面的数据结构，实现如下边代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* arch/x86/include/asm/pgtable.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pte_page(pte)   pfn_to_page(pte_pfn(pte))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">130</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">pte_pfn</span>(<span style="color:#66d9ef">pte_t</span> pte)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">131</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">132</span>         <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">pte_val</span>(pte) <span style="color:#f92672">&amp;</span> PTE_PFN_MASK) <span style="color:#f92672">&gt;&gt;</span> PAGE_SHIFT;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    	176 /* PTE_PFN_MASK extracts the PFN from a (pte|pmd|pud|pgd)val_t */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">177</span> <span style="color:#960050;background-color:#1e0010">#</span>define <span style="color:#a6e22e">PTE_PFN_MASK</span>            ((<span style="color:#66d9ef">pteval_t</span>)PHYSICAL_PAGE_MASK)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">133</span> }
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*include/asm-generic/memory_model.h*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">70</span> <span style="color:#960050;background-color:#1e0010">#</span>define pfn_to_page __pfn_to_page
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30</span> <span style="color:#960050;background-color:#1e0010">#</span>define <span style="color:#a6e22e">__pfn_to_page</span>(pfn)      (mem_map <span style="color:#f92672">+</span> ((pfn) <span style="color:#f92672">-</span> ARCH_PFN_OFFSET))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">8</span> <span style="color:#960050;background-color:#1e0010">#</span>ifndef ARCH_PFN_OFFSET
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">9</span> <span style="color:#960050;background-color:#1e0010">#</span>define <span style="color:#a6e22e">ARCH_PFN_OFFSET</span>         (<span style="color:#ae81ff">0UL</span>)
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">10</span> <span style="color:#960050;background-color:#1e0010">#</span>endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">即
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    pte_page(pte) 展开为 (mem_map + ((pte) - 0))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    其中pte = (pte_val(pte) &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><h3 id="struct-zone"><code>struct zone</code></h3>
<p>关于<code>zone</code>的划分，内核中的注释应该能够帮助理解。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> zone_type {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ZONE_DMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * ZONE_DMA is used when there are devices that are not able
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to do DMA to all of addressable memory (ZONE_NORMAL). Then we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * carve out the portion of memory that is needed for these devices.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * The range is arch specific.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Some examples
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Architecture         Limit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * ---------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * parisc, ia64, sparc  &lt;4G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * s390                 &lt;2G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * arm                  Various
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * alpha                Unlimited or 0-16MB.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * i386, x86_64 and multiple other arches
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *                      &lt;16M.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ZONE_DMA,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ZONE_DMA32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * x86_64 needs two ZONE_DMAs because it supports devices that are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * only able to do DMA to the lower 16M but also 32 bit devices that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * can only do DMA areas below 4G.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ZONE_DMA32,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Normal addressable memory is in ZONE_NORMAL. DMA operations can be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * performed on pages in ZONE_NORMAL if the DMA devices support
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * transfers to all addressable memory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ZONE_NORMAL,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_HIGHMEM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * A memory area that is only addressable by the kernel through
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * mapping portions into its own address space. This is for example
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * used by i386 to allow the kernel to address the memory beyond
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 900MB. The kernel will set up special mappings (page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * table entries on i386) for each page that the kernel needs to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * access.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ZONE_HIGHMEM,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ZONE_MOVABLE,
</span></span><span style="display:flex;"><span>        __MAX_NR_ZONES
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>zone</code>结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* &#34;include/linux/mmzone.h&#34; */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> zone {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Fields commonly accessed by the page allocator */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           pages_min, pages_low, pages_high;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * We don&#39;t know if the memory that we&#39;re going to allocate will be freeable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * or/and it will be released eventually, so to avoid totally wasting several
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * GB of ram we must reserve some of the lower zone memory (otherwise we risk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to run OOM on the lower zones despite there&#39;s tons of freeable ram
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * on the higher zones). This array is recalculated at runtime if the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * sysctl_lowmem_reserve_ratio sysctl changes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           lowmem_reserve[MAX_NR_ZONES];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> node;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * zone reclaim becomes active if more unmapped pages exist.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           min_unmapped_pages;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           min_slab_pages;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> per_cpu_pageset  <span style="color:#f92672">*</span>pageset[NR_CPUS];
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> per_cpu_pageset  pageset[NR_CPUS];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * free areas of different sizes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">spinlock_t</span>              lock;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MEMORY_HOTPLUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/* see spanned/present_pages for more description */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">seqlock_t</span>               span_seqlock;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> free_area        free_area[MAX_ORDER]; <span style="color:#75715e">/* &#34;空闲区间&#34;队列 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 省略一些元素 */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Discontig memory support fields.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> pglist_data      <span style="color:#f92672">*</span>zone_pgdat; <span style="color:#75715e">/* 属于哪个NUMA节点 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           zone_start_pfn; <span style="color:#75715e">/* 在page结构数组中的起始页面号 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * zone_start_pfn, spanned_pages and present_pages are all
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * protected by span_seqlock.  It is a seqlock because it has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to be read outside of zone-&gt;lock, and it is done in the main
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * allocator path.  But, it is written quite infrequently.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * The lock is declared along with zone-&gt;lock because it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * frequently read in proximity to zone-&gt;lock.  It&#39;s good to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * give them a chance of being in the same cacheline.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           spanned_pages;  <span style="color:#75715e">/* total size, including holes */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           present_pages;  <span style="color:#75715e">/* amount of memory (excluding holes) */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * rarely used fields:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span>              <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>} ____cacheline_internodealigned_in_smp;
</span></span></code></pre></div><h3 id="pg_data_t-或者-struct-pglist_data-"><code>pg_data_t</code> 或者 <code>struct pglist_data </code></h3>
<p>此结构表示每个<code>NUMA</code>节点的存储信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* include/linux/mmzone.h */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * (mostly NUMA machines?) to denote a higher-level memory zone than the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * zone denotes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * On NUMA machines, each NUMA node would have a pg_data_t to describe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * it&#39;s memory layout.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Memory statistics and page replacement data structures are maintained on a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * per-zone basis.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> pglist_data {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> zone node_zones[MAX_NR_ZONES]; <span style="color:#75715e">/* 节点内的 zone，数组 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> zonelist node_zonelists[MAX_ZONELISTS]; <span style="color:#75715e">/* 分配策略数组 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nr_zones;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_FLAT_NODE_MEM_MAP </span><span style="color:#75715e">/* means !SPARSEMEM */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>node_mem_map;  <span style="color:#75715e">/* 指向具体节点内的page数组 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_CGROUP_MEM_RES_CTLR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> page_cgroup <span style="color:#f92672">*</span>node_page_cgroup;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> bootmem_data <span style="color:#f92672">*</span>bdata;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MEMORY_HOTPLUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Must be held any time you expect node_start_pfn, node_present_pages
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * or node_spanned_pages stay constant.  Holding this will also
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * guarantee that any pfn_valid() stays that way.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Nests above zone-&gt;lock and zone-&gt;size_seqlock.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">spinlock_t</span> node_size_lock;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_start_pfn;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_present_pages; <span style="color:#75715e">/* total number of physical pages */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_spanned_pages; <span style="color:#75715e">/* total size of physical page 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        									range, including holes */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> node_id;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">wait_queue_head_t</span> kswapd_wait;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>kswapd;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> kswapd_max_order;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">pg_data_t</span>;
</span></span></code></pre></div><p>每个<code>zonelist</code>规定了一种分配策略，当当前节点中的物理页面不够时，按<code>zonelist</code>中的顺序，从公共存储或者其他cpu的存储中分配页面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * One allocation request operates on a zonelist. A zonelist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * is a list of zones, the first one is the &#39;goal&#39; of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * allocation, the other zones are fallback zones, in decreasing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * priority.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * If zlcache_ptr is not NULL, then it is just the address of zlcache,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * as explained above.  If zlcache_ptr is NULL, there is no zlcache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * To speed the reading of the zonelist, the zonerefs contain the zone index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * of the entry being read. Helper functions to access information given
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * a struct zoneref are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * zonelist_zone()      - Return the struct zone * for an entry in _zonerefs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * zonelist_zone_idx()  - Return the index of the zone for an entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * zonelist_node_idx()  - Return the index of the node for an entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> zonelist {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> zonelist_cache <span style="color:#f92672">*</span>zlcache_ptr;                  <span style="color:#75715e">// NULL or &amp;zlcache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> zoneref _zonerefs[MAX_ZONES_PER_ZONELIST <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> zonelist_cache zlcache;                       <span style="color:#75715e">// optional ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 其中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This struct contains information about a zone in a zonelist. It is stored
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * here to avoid dereferences into large structures and lookups of tables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> zoneref {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone;      <span style="color:#75715e">/* Pointer to actual zone */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> zone_idx;           <span style="color:#75715e">/* zone_idx(zoneref-&gt;zone) */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<p>之前的几个结构都是用于物理空间管理的，下面是虚拟空间管理的。</p>
<p>虚拟空间的管理是以进程为基础的，每个进程都有各自的虚拟内存空间，所有进程的内核空间是共享的。</p>
<p><img alt="image-20201209182949066" src="image-20201209182949066.png"></p>
<h3 id="struct-vm_area_struct"><code>struct vm_area_struct</code></h3>
<p>一个进程所需要使用的虚拟空间中的各个部位未必连续，通常形成若干离散的虚存<strong>区间</strong>，对虚存区间的抽象就是数据结构<code>struct vm_area_struct</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* include/linux/mm_types.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This struct defines a memory VMM memory area. There is one of these
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * per VM-area/task.  A VM area is any part of the process virtual memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * space that has a special rule for the page-fault handlers (ie a shared
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * library, the executable area etc).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_area_struct {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span> vm_mm;       <span style="color:#75715e">/* The address space we belong to. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_start;         <span style="color:#75715e">/* Our start address within vm_mm. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_end;           <span style="color:#75715e">/* The first byte after our end address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                           within vm_mm. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* linked list of VM areas per task, sorted by address */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vm_next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pgprot_t</span> vm_page_prot;          <span style="color:#75715e">/* Access permissions of this VMA. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags;         <span style="color:#75715e">/* Flags, see mm.h. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> rb_node vm_rb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * For areas with an address space and backing store,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * linkage into the address_space-&gt;i_mmap prio tree, or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * linkage to the list of like vmas hanging off its node, or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">struct</span> list_head list;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>parent;   <span style="color:#75715e">/* aligns with prio_tree_node parent */</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>                } vm_set;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">struct</span> raw_prio_tree_node prio_tree_node;
</span></span><span style="display:flex;"><span>        } shared;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * A file&#39;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * list, after a COW of one of the file pages.  A MAP_SHARED vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * or brk vma (with NULL file) can only be in an anon_vma list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head anon_vma_node; <span style="color:#75715e">/* Serialized by anon_vma-&gt;lock */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> anon_vma <span style="color:#f92672">*</span>anon_vma;      <span style="color:#75715e">/* Serialized by page_table_lock */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Function pointers to deal with this struct. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> vm_operations_struct <span style="color:#f92672">*</span> vm_ops;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Information about our backing store: */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_pgoff;         <span style="color:#75715e">/* Offset (within vm_file) in PAGE_SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                           units, *not* PAGE_CACHE_SIZE */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span> vm_file;          <span style="color:#75715e">/* File we map to (can be NULL). */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> vm_private_data;         <span style="color:#75715e">/* was vm_pte (shared mem) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_truncate_count;<span style="color:#75715e">/* truncate_count or restart_addr */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_MMU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> vm_region <span style="color:#f92672">*</span>vm_region;    <span style="color:#75715e">/* NOMMU mapping region */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> mempolicy <span style="color:#f92672">*</span>vm_policy;    <span style="color:#75715e">/* NUMA policy for the VMA */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ul>
<li><code>vm_mm</code> : 指向一个<code>mm_struct</code>结构，是比<code>vm_area_struct</code>更高层次的结构，隶属于<code>task_struct</code>。</li>
<li><code>vm_start</code>和<code>vm_end</code> : 决定了虚存区间，前闭后开即start在区间内，end不包含在区间内；</li>
<li><code>vm_next</code> :  隶属于同一个进程的所有区间的结构链表指针；</li>
<li><code>vm_page_prot</code> 和<code>vm_flags</code> : 表示同一个区间所有页面相同的访问权限以及其他一些属性；</li>
<li><code>vm_rb</code> :   红黑树节点，当区间数量较大时只通过<code>vm_next</code>链式搜索速度太慢，加速搜索；</li>
<li><code>vm_ops</code> : 指向一个<code>vm_operations_struct</code>指针，此结构中保存了一些函数指针，用于操作此区间，比如打开，关闭，建立映射以及处理缺页异常等操作。</li>
<li>在两种情况下虚存页面（或区间）会和磁盘文件发生联系，<code>mapping</code>  <code>vm_file</code>等几个结构保存这种联系。
<ul>
<li>swap，内存页面不够分配时，将一些久未使用的页面交换到磁盘上去；</li>
<li>通过<code>mmap()</code>将一个磁盘文件映射到进程的用户空间。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * These are the virtual MM functions - opening of an area, closing and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * unmapping it (needed to keep files on disk up-to-date etc), pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * to the functions called when a no-page or a wp-page exception occurs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_operations_struct {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>open)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> area);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>close)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> area);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fault)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* notification that a previously read-only page is about to become
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * writable, if an error is returned it will cause a SIGBUS */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>page_mkwrite)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* called by access_process_vm when get_user_pages() fails, typically
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * for use by special VMAs that can switch between memory and hardware
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>access)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>                      <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">int</span> len, <span style="color:#66d9ef">int</span> write);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * set_policy() op must add a reference to any non-NULL @new mempolicy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to hold the policy upon return.  Caller should pass NULL @new to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * remove a policy and fall back to surrounding context--i.e. do not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * install a MPOL_DEFAULT policy, nor the task or system default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * mempolicy.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>set_policy)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">struct</span> mempolicy <span style="color:#f92672">*</span>new);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * get_policy() op must add reference [mpol_get()] to any policy at
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * in mm/mempolicy.c will do this automatically.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * get_policy() must NOT add a ref if the policy at (vma,addr) is not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * If no [shared/vma] mempolicy exists at the addr, get_policy() op
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * must return NULL--i.e., do not &#34;fallback&#34; to task or system default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * policy.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> mempolicy <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>get_policy)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma,
</span></span><span style="display:flex;"><span>                                        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>migrate)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">nodemask_t</span> <span style="color:#f92672">*</span>from,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">nodemask_t</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="struct-mm_struct"><code>struct mm_struct</code></h3>
<p>每个进程只有一个<code>mm_struct</code>结构，<code>mm_struct</code>是进程整个用户空间的抽象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* &#34;include/linux/mm_types.h&#34; */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> mm_struct {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> mmap;           <span style="color:#75715e">/* list of VMAs */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> rb_root mm_rb;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> mmap_cache;     <span style="color:#75715e">/* last find_vma result */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">long</span> (<span style="color:#f92672">*</span>get_unmapped_area) (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp,
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len,
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pgoff, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>unmap_area) (<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> mmap_base;                <span style="color:#75715e">/* base of mmap area */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> task_size;                <span style="color:#75715e">/* size of task vm space */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> cached_hole_size;         <span style="color:#75715e">/* if non-zero, the largest hole below free_area_cache */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> free_area_cache;          <span style="color:#75715e">/* first hole of size cached_hole_size or larger */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span> pgd;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">atomic_t</span> mm_users;                      <span style="color:#75715e">/* How many users with user space? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">atomic_t</span> mm_count;                      <span style="color:#75715e">/* How many references to &#34;struct mm_struct&#34; (users count as 1) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> map_count;                          <span style="color:#75715e">/* number of VMAs */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> rw_semaphore mmap_sem;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">spinlock_t</span> page_table_lock;             <span style="color:#75715e">/* Protects page tables and some counters */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head mmlist;                <span style="color:#75715e">/* List of maybe swapped mm&#39;s.  These are globally strung
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * together off init_mm.mmlist, and are protected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 * by mmlist_lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Special counters, in some configurations protected by the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * page_table_lock, in other configurations by being atomic.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">mm_counter_t</span> _file_rss;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">mm_counter_t</span> _anon_rss;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> hiwater_rss;      <span style="color:#75715e">/* High-watermark of RSS usage */</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> hiwater_vm;       <span style="color:#75715e">/* High-water virtual memory usage */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> total_vm, locked_vm, shared_vm, exec_vm;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_code, end_code, start_data, end_data;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_brk, brk, start_stack;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg_start, arg_end, env_start, env_end;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> saved_auxv[AT_VECTOR_SIZE]; <span style="color:#75715e">/* for /proc/PID/auxv */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">cpumask_t</span> cpu_vm_mask;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Architecture-specific MM context */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">mm_context_t</span> context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Swap token stuff */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Last value of global fault stamp as seen by this process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * In other words, this value gives an indication of how long
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * it has been since this task got the token.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Look at mm/thrash.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> faultstamp;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> token_priority;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> last_interval;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags; <span style="color:#75715e">/* Must use atomic bitops to access the bits */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> core_state <span style="color:#f92672">*</span>core_state; <span style="color:#75715e">/* coredumping support */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* aio bits */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">spinlock_t</span>              ioctx_lock;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> hlist_head       ioctx_list;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MM_OWNER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * &#34;owner&#34; points to a task that is regarded as the canonical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * user/owner of this mm. All of the following must be true in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * order for it to be changed:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * current == mm-&gt;owner
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * current-&gt;mm != mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * new_owner-&gt;mm == mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * new_owner-&gt;alloc_lock is held
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>owner;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_PROC_FS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>exe_file;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> num_exe_file_vmas;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MMU_NOTIFIER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> mmu_notifier_mm <span style="color:#f92672">*</span>mmu_notifier_mm;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ul>
<li><code>* mmap</code> ： 用来建立一个虚存区间<code>vm_area_struct</code>的单链线性队列；</li>
<li><code>mm_rb</code> : 用来建立<code>vm_area_struct</code>的红黑树结构；</li>
<li><code>* mmap_cache</code> : 用来指向最近一次用到的<code>vm_area_struct</code>结构；</li>
<li><code>* pgd</code> : 指向该进程的页表目录，当内核调度一个进程进入运行时，就将这个地址转换成物理地址，并写入<code>CR3</code>寄存器；</li>
<li><code>map_count</code> : 说明此进程有多少个<code>vm_area_struct</code>结构；</li>
<li><code>mm_users</code>和<code>mm_count</code> : <code>atomic_t</code>（原子）类型，一个进程只能有一个<code>mm_struct</code>，但是一个<code>mm_struct</code>可能同时为多个进程服务，此两个变量用以计数。</li>
<li><code>mmap_sem</code>和<code>page_table_lock</code> : 用于此结构的信号量和用于页表的锁，用于进程间的互斥和并发；</li>
<li><code>start_code, end_code, start_data, end_data</code> : 进程的代码段、数据段，此外还有堆栈段等的起点和终点。</li>
</ul>
<h2 id="内存管理基本框架">内存管理基本框架</h2>
<p><img alt="image-20201216171309001" src="image-20201216171309001.png"></p>
<p><strong>管理区分配器</strong>接收动态内存分配与释放的请求，在请求分配的情况下，该部分搜索一个能满足所请求的一组连续的页框的内存管理区。在每个<strong>管理区</strong>内，页框被<strong>伙伴算法系统</strong>处理。每CPU页框高速缓存包含一些预先分配，它们被用于满足本地CPU发出的单一内存请求。</p>
<h2 id="伙伴系统">伙伴系统</h2>
<p>网上超了一段算法的简单描述如下。</p>
<blockquote>
<p>为了便于页面的维护，将多个页面组成内存块，每个内存块都有 2 的方幂个页，方幂的指数被称为阶 order。order相同的内存块被组织到一个空闲链表中。伙伴系统基于2的方幂来申请释放内存页。
当申请内存页时，伙伴系统首先检查与申请大小相同的内存块链表中，检看是否有空闲页，如果有就将其分配出去，并将其从链表中删除，否则就检查上一级，即大小为申请大小的2倍的内存块空闲链表，如果该链表有空闲内存，就将其分配出去，同时将剩余的一部分（即未分配出去的一半）加入到下一级空闲链表中；如果这一级仍没有空闲内存；就检查它的上一级，依次类推，直到分配成功或者彻底失败，在成功时还要按照伙伴系统的要求，将未分配的内存块进行划分并加入到相应的空闲内存块链表
在释放内存页时，会检查其伙伴是否也是空闲的，如果是就将它和它的伙伴合并为更大的空闲内存块，该检查会递归进行，直到发现伙伴正在被使用或者已经合并成了最大的内存块。</p>
</blockquote>
<p>在linux中可以通过命令<code>cat /proc/buddyinfo</code>查看系统中伙伴系统使用情况。</p>
<p><img alt="image-20201216191346937" src="image-20201216191346937.png"></p>
<p>此处以DMA区域进行分析，第二列值为4，表示当前系统中DMA区域，可用的连续两页的内存大小为4*2*PAGE_SIZE；第三列值为21，表示当前系统中DMA区域，可用的连续四页的内存大小为21*2^2*PAGE_SIZE。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* include/mm/mmzone.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Free memory management - zoned buddy allocator.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_FORCE_MAX_ZONEORDER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_ORDER 11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_ORDER_NR_PAGES (1 &lt;&lt; (MAX_ORDER - 1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> zone {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 略 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> free_area free_area[MAX_ORDER];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 略 */</span>
</span></span><span style="display:flex;"><span>}<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIGRATE_UNMOVABLE     0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIGRATE_RECLAIMABLE   1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIGRATE_MOVABLE       2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIGRATE_RESERVE       3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIGRATE_ISOLATE       4 </span><span style="color:#75715e">/* can&#39;t allocate from here */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIGRATE_TYPES         5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> free_area {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head        free_list[MIGRATE_TYPES];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           nr_free;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li><code>nr_free</code>:其中<code>nr_free</code>表示<strong>内存页块</strong>的数目，对于0阶的表示以1页为单位计算，对于1阶的以2页为单位计算，n阶的以2的n次方为单位计算。</li>
<li><code>free_list</code>:用于将具有该大小的内存页块连接起来。由于<strong>内存页块</strong>表示的是<strong>连续的物理页</strong>，因而对于加入到链表中的每个内存页块来说，只需要将内存页块中的第一个页加入该链表即可。因此这些链表连接的是每个内存页块中第一个内存页，使用了<code>struct page</code>中的<code>struct list_head lru</code>成员。free_list数组元素的每一个对应一种属性的类型，可用于不同的目地，但是它们的大小和组织方式相同。</li>
</ul>
<p>每个<code>struct zone</code>都有11(<code>MAX_ORDER</code>)个<code>struct free_area</code>结构，每一个<code>free_area</code>包含5(<code>MIGRATE_TYPES</code>)个链表，其中每一个链表中的内存页面按照其自身是否可以释放或者迁移被归为一类，于是凡是请求“不可迁移”页面的分配请求全部在<code>free_list[MIGRATE_UNMOVABLE]</code>这条链表上分配。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* include/linux/mm_types.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> page{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 略 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> list_head lru;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 略 */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><img alt="Memery_Layout_21" src="Memery_Layout_21.jpg"></p>
<p>参考</p>
<p><a href="https://blog.csdn.net/lickylin/article/details/50726847">Linux /proc/buddyinfo理解</a></p>
<p><a href="https://www.phpfans.net/ask/MTIyMDc1MQ.html">linux 2.6.36的free_area结构</a></p>
<p><a href="https://blog.csdn.net/jus3ve/article/details/79736898">linux内核对伙伴系统的改进&ndash;migrate_type</a></p>
<p><a href="https://blog.csdn.net/goodluckwhh/article/details/9989695?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control">linux内核内存管理学习之二（物理内存管理&ndash;伙伴系统）</a></p>
<h2 id="slab系统">slab系统</h2>
<p>伙伴算法系统采用页框作为基本内存区，这适合于对大块内存的请求，但是如何处理小内存的请求，比如说几十或者几百个字节？linux kernel采用<code>slab</code>系统进行高效的小内存管理。</p>
<p><code>make menuconfig</code>后输入<code>/</code>搜索<code>slab</code>后回车，会看到下图的路径。</p>
<p><img alt="image-20201216141235787" src="image-20201216141235787.png"></p>
<p>此外还有</p>
<ul>
<li>SLAB是基础，是最早从Sun OS那引进的；</li>
<li>SLUB是在Slab上进行的改进，在大型机上表现出色，据说还被IA-64作为默认；</li>
<li>SLOB是针对小型系统设计的，主要是嵌入式。</li>
</ul>
<p><code>slab</code>分配器把对象分组放进<strong>高速缓存</strong>，每个高速缓存都是同种类型对象的“储备”。例如，当一个文件被打开时，存放相应“打开文件”对象所需的内存区是从一个叫做<code>filp</code>的<code>slab</code>分配器的高速缓存中得到的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat /proc/slabinfo  <span style="color:#75715e">#查看系统中slab使用情况</span>
</span></span></code></pre></div><p><img alt="image-20201217165809700" src="image-20201217165809700.png"></p>
<p>也可以使用<code>slabtop</code>命令查看<code>slab</code>系统使用情况。</p>
<p><img alt="image-20201217165714560" src="image-20201217165714560.png"></p>
<ul>
<li>OBJS — The total number of objects (memory blocks), including those in use (allocated), and some spares not in use.</li>
<li>ACTIVE — The number of objects (memory blocks) that are in use (allocated).</li>
<li>USE — Percentage of total objects that are active. ((ACTIVE/OBJS)(100))</li>
<li>OBJ SIZE — The size of the objects.</li>
<li>SLABS — The total number of slabs.</li>
<li>OBJ/SLAB — The number of objects that fit into a slab.</li>
<li>CACHE SIZE — The cache size of the slab.</li>
<li>NAME — The name of the slab.</li>
</ul>
<p>包含高速缓存的主内存区域被划分为多个<code>slab</code>，每个<code>slab</code>由一个或多个连续的页框组成，这些页框中既包含已经分配的对象，也包含空闲的对象。</p>
<p><img alt="slab" src="Slab_Cache.png"></p>
<p>每个高速缓存都是由<code>struct kmem_cache</code>类型的数据结构来描述的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* mm/slab.c */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct kmem_cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * manages a cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 1) per-cpu data, touched during every alloc/free */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> array_cache <span style="color:#f92672">*</span>array[NR_CPUS];
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 2) Cache tunables. Protected by cache_chain_mutex */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> batchcount;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> limit;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> shared;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> buffer_size;
</span></span><span style="display:flex;"><span>        u32 reciprocal_buffer_size;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 3) touched by every alloc &amp; free from the backend */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags;             <span style="color:#75715e">/* constant flags */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> num;               <span style="color:#75715e">/* # of objs per slab */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 4) cache_grow/shrink */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* order of pgs per slab (2^n) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> gfporder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* force GFP flags, e.g. GFP_DMA */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">gfp_t</span> gfpflags;					<span style="color:#75715e">/* 分配页框时传递给伙伴系统函数的一组标志 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">size_t</span> colour;                  <span style="color:#75715e">/* cache colouring range */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> colour_off;        <span style="color:#75715e">/* colour offset */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>slabp_cache;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> slab_size;			<span style="color:#75715e">/* 单个slab的大小 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> dflags;            <span style="color:#75715e">/* dynamic flags */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* constructor func */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>ctor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 5) cache creation/removal */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;				<span style="color:#75715e">/* 存放高速缓存的名字 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head next;			<span style="color:#75715e">/* 高速缓存描述符双向链表使用的指针 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 6) statistics */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if STATS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> num_active;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> num_allocations;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> high_mark;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> grown;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> reaped;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> errors;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> max_freeable;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_allocs;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_frees;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_overflow;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">atomic_t</span> allochit;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">atomic_t</span> allocmiss;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * If debugging is enabled, then the allocator can add additional
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * fields and/or padding to every object. buffer_size contains the total
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * object size including these internal fields, the following two
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * variables contain the offset to the user object and its size.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> obj_offset;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> obj_size;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * We put nodelists[] at the end of kmem_cache, because we want to size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * this array to nr_node_ids slots instead of MAX_NUMNODES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * (see kmem_cache_init())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * is statically defined, so we reserve the max number of nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> kmem_list3 <span style="color:#f92672">*</span>nodelists[MAX_NUMNODES];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Do not add fields after nodelists[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>第一个元素是<code> struct array_cache</code>，其定义如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#66d9ef">struct</span> array_cache {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> avail; <span style="color:#75715e">/* 可用对象数目 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> limit; <span style="color:#75715e">/* 可拥有的最大对象数目，和kmem_cache中一样 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> batchcount; <span style="color:#75715e">/* 同kmem_cache，要转移进本地高速缓存或从本地高速缓存中转移出去的对象的个数 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> touched; <span style="color:#75715e">/* 是否在收缩后被访问过 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">spinlock_t</span> lock;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>entry[];  <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                         * Must have this definition in here for the proper
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                         * alignment of array_cache. Also simplifies accessing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                         * the entries.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                         */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* entry是一个伪数组，初始没有任何数据项，之后会增加并保存释放的对象指针 */</span>
</span></span><span style="display:flex;"><span>};    
</span></span></code></pre></div><p>其中<code>kmem_list3</code>结构主要保存了三个<code>slab</code>结构链表，是<code>slab</code>系统的核心，其定义如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* mm/slab.c */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The slab lists for all objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_list3 {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head slabs_partial; <span style="color:#75715e">/* partial list first, better asm code */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head slabs_full;	<span style="color:#75715e">/* 不包含空闲对象的slab描述符双向循环链表 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head slabs_free;	<span style="color:#75715e">/* 只包含空闲对象的slab描述符双向循环链表 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> free_objects;		<span style="color:#75715e">/* 高速缓存中空闲对象的个数 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> free_limit;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> colour_next;       <span style="color:#75715e">/* Per-node cache coloring */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">spinlock_t</span> list_lock;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> array_cache <span style="color:#f92672">*</span>shared;     <span style="color:#75715e">/* shared per node */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> array_cache <span style="color:#f92672">**</span>alien;     <span style="color:#75715e">/* on other nodes */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> next_reap;        <span style="color:#75715e">/* updated without locking */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> free_touched;               <span style="color:#75715e">/* updated without locking */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>slab</code>描述符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* mm/slab.c */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Manages the objs in a slab. Placed either at the beginning of mem allocated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * for a slab, or allocated from an general cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Slabs are chained into three list: fully used, partial, fully free slabs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> slab {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> list_head list;	<span style="color:#75715e">/* slab描述符的三个双向循环链表中的一个 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> colouroff;<span style="color:#75715e">/* slab中第一个对象的偏移 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>s_mem;            <span style="color:#75715e">/* including colour offset slab中第一个对象的地址 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> inuse;     <span style="color:#75715e">/* num of objs active in slab 正在使用的非空闲slab的对象个数*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">kmem_bufctl_t</span> free;		<span style="color:#75715e">/* slab中下一个空闲对象的下标 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> nodeid;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><img alt="slab对象关系" src="http://chenweixiang.github.io/assets/Memery_Layout_14.jpg"></p>
<p><img alt="image-20201216150001694" src="image-20201216150001694.png"></p>
<h3 id="slab分配器的接口">slab分配器的接口</h3>
<ul>
<li>新建一个高速缓存</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * kmem_cache_create - Create a cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @name: A string which is used in /proc/slabinfo to identify this cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @size: The size of objects to be created in this cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @align: The required alignment for the objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @flags: SLAB flags
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @ctor: A constructor for the objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Returns a ptr to the cache on success, NULL on failure.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Cannot be called within a int, but can be interrupted.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The @ctor is run when new pages are allocated by the cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @name must be valid until the cache is destroyed. This implies that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * the module calling this has to destroy the cache before getting unloaded.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Note that kmem_cache_name() is not guaranteed to return the same pointer,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * therefore applications must manage it themselves.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The flags are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * to catch references to uninitialised memory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * %SLAB_RED_ZONE - Insert `Red&#39; zones around the allocated memory to check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * for buffer overruns.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * cacheline.  This can be beneficial if you&#39;re counting cycles as closely
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * as davem.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kmem_cache_create</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">size_t</span> align,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>ctor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>));
</span></span></code></pre></div><ul>
<li>销毁一个高速缓存</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * kmem_cache_destroy - delete a cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @cachep: the cache to destroy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Remove a &amp;struct kmem_cache object from the slab cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * It is expected this function will be called by a module when it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * unloaded.  This will remove the cache completely, and avoid a duplicate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * cache being allocated each time a module is loaded and unloaded, if the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * module doesn&#39;t have persistent in-kernel storage across loads and unloads.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The cache must be empty before calling this function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The caller must guarantee that noone will allocate memory from the cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * during the kmem_cache_destroy().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kmem_cache_destroy</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep);   
</span></span></code></pre></div><ul>
<li>从缓存中分配对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * kmem_cache_alloc - Allocate an object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @cachep: The cache to allocate from.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @flags: See kmalloc().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Allocate an object from this cache.  The flags are only relevant
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * if the cache has no available objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kmem_cache_alloc</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep, <span style="color:#66d9ef">gfp_t</span> flags);
</span></span></code></pre></div><ul>
<li>释放对象回高速缓存</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * kmem_cache_free - Deallocate an object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @cachep: The cache the allocation was from.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @objp: The previously allocated object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Free an object which was previously allocated from this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kmem_cache_free</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>objp);
</span></span></code></pre></div><ul>
<li>一个示例</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* 1. 定义一个全局变量存放指向task_struct高速缓存的指针 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>task_struct_cachep;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 2. 内核初始化期间，在kernel/fork.c中的fork_init()中会创建高速缓存 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* create a slab on which task_structs can be allocated */</span>
</span></span><span style="display:flex;"><span>task_struct_cachep <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_cache_create</span>(<span style="color:#e6db74">&#34;task_struct&#34;</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> task_struct), ARCH_MIN_TASKALIGN, SLAB_PANIC, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 3. 从task_struct_cachep中分配对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	do_fork() -&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		copy_process() -&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			dup_task_struct() -&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				struct task_struct *tsk;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				tsk = alloc_task_struct();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">其中alloc_task_struct() 定义为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># define alloc_task_struct()    kmem_cache_alloc(task_struct_cachep, GFP_KERNEL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># define free_task_struct(tsk)  kmem_cache_free(task_struct_cachep, (tsk))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>task_struct_cachep;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* 即 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk;
</span></span><span style="display:flex;"><span>tsk <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_cache_alloc</span>(task_struct_cachep, GFP_KERNEL);
</span></span></code></pre></div><h3 id="slab系统申请页框">slab系统申请页框</h3>
<p>当<code>slab</code>分配器创建新的<code>slab</code>时，它依靠<strong>分区页框分配器</strong>来获得一组连续的空闲页框（一般是从伙伴系统获得）。一般调用<code>kmem_gerpages()</code>函数实现。</p>
<h3 id="给高速缓存分配slab">给高速缓存分配slab</h3>
<p>只有当 已发出一个分配新对象的请求，且高速缓存不包含任何空闲对象时，才给高速缓存分配slab。</p>
<p>slab分配器通过调用<code>cache_grow()</code>函数给高速缓存分配一个新的slab。<code>cache_grow()</code>调用<code>kmem_getpages()</code>获得一组页框来存放一个单独的slab，然后调用<code>alloc_slabmgmt()</code>函数获得一个新的slab描述符。接着调用<code>cache_init_objs()</code>函数，它将构造方法应用到新的slab包含的所有对象上，最后调用<code>list_add_tail()</code>来讲新得到的slab描述符<code>*slabp</code>，添加到高速缓存描述符<code>*cachep</code>的全空slab链表的末端，并更新告诉缓存中的空闲对象计数器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* mm/slab.c&#34; */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Grow (by 1) the number of slabs within a cache.  This is called by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * kmem_cache_alloc() when there are no active objs left in a cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cache_grow</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">gfp_t</span> flags, <span style="color:#66d9ef">int</span> nodeid, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>objp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> slab <span style="color:#f92672">*</span>slabp;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">size_t</span> offset;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">gfp_t</span> local_flags;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> kmem_list3 <span style="color:#f92672">*</span>l3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Be lazy and only check for valid flags here,  keeping it out of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * critical path in kmem_cache_alloc().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">BUG_ON</span>(flags <span style="color:#f92672">&amp;</span> GFP_SLAB_BUG_MASK);
</span></span><span style="display:flex;"><span>        local_flags <span style="color:#f92672">=</span> flags <span style="color:#f92672">&amp;</span> (GFP_CONSTRAINT_MASK<span style="color:#f92672">|</span>GFP_RECLAIM_MASK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Take the l3 list lock to change the colour_next on this node */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">check_irq_off</span>();
</span></span><span style="display:flex;"><span>        l3 <span style="color:#f92672">=</span> cachep<span style="color:#f92672">-&gt;</span>nodelists[nodeid];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>l3<span style="color:#f92672">-&gt;</span>list_lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Get colour for the slab, and cal the next value. */</span>
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> l3<span style="color:#f92672">-&gt;</span>colour_next;
</span></span><span style="display:flex;"><span>        l3<span style="color:#f92672">-&gt;</span>colour_next<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (l3<span style="color:#f92672">-&gt;</span>colour_next <span style="color:#f92672">&gt;=</span> cachep<span style="color:#f92672">-&gt;</span>colour)
</span></span><span style="display:flex;"><span>                l3<span style="color:#f92672">-&gt;</span>colour_next <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>l3<span style="color:#f92672">-&gt;</span>list_lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">*=</span> cachep<span style="color:#f92672">-&gt;</span>colour_off;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (local_flags <span style="color:#f92672">&amp;</span> __GFP_WAIT)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * The test for missing atomic flag is performed here, rather than
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * the more obvious place, simply to reduce the critical path length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * in kmem_cache_alloc(). If a caller is seriously mis-behaving they
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * will eventually be caught here (where it matters).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kmem_flagcheck</span>(cachep, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Get mem for the objs.  Attempt to allocate a physical page from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * &#39;nodeid&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>objp)
</span></span><span style="display:flex;"><span>                objp <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_getpages</span>(cachep, local_flags, nodeid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>objp)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">goto</span> failed;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Get slab management. */</span>
</span></span><span style="display:flex;"><span>        slabp <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_slabmgmt</span>(cachep, objp, offset,
</span></span><span style="display:flex;"><span>                        local_flags <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>GFP_CONSTRAINT_MASK, nodeid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>slabp)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">goto</span> opps1;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">slab_map_pages</span>(cachep, slabp, objp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cache_init_objs</span>(cachep, slabp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (local_flags <span style="color:#f92672">&amp;</span> __GFP_WAIT)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">local_irq_disable</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">check_irq_off</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>l3<span style="color:#f92672">-&gt;</span>list_lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Make slab active. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>slabp<span style="color:#f92672">-&gt;</span>list, <span style="color:#f92672">&amp;</span>(l3<span style="color:#f92672">-&gt;</span>slabs_free));
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">STATS_INC_GROWN</span>(cachep);
</span></span><span style="display:flex;"><span>        l3<span style="color:#f92672">-&gt;</span>free_objects <span style="color:#f92672">+=</span> cachep<span style="color:#f92672">-&gt;</span>num;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>l3<span style="color:#f92672">-&gt;</span>list_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>opps1:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kmem_freepages</span>(cachep, objp);
</span></span><span style="display:flex;"><span>failed:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (local_flags <span style="color:#f92672">&amp;</span> __GFP_WAIT)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">local_irq_disable</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">简单总结cache_grow()的流程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">static int cache_grow(struct kmem_cache *cachep,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                gfp_t flags, int nodeid, void *objp)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	objp = kmem_getpages(cachep, local_flags, nodeid);  //获得页框
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        slabp = alloc_slabmgmt(cachep, objp, offset,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                        local_flags &amp; ~GFP_CONSTRAINT_MASK, nodeid); //获得一个新的slab描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        cache_init_objs(cachep, slabp);   // 初始化slab   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        list_add_tail(&amp;slabp-&gt;list, &amp;(l3-&gt;slabs_free)); //将新分配的slab加入到空闲链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        l3-&gt;free_objects += cachep-&gt;num; //更新空闲slab计数器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><p><a href="https://www.cnblogs.com/linhaostudy/p/10467992.html">关于高端内存</a></p>
<h2 id="全文参考">全文参考</h2>
<p><a href="http://chenweixiang.github.io/2019/01/18/linux-kernel-reading.html#6-2-3-struct-zone">大佬的blog</a></p>
<p>ULK3</p>
<p>LKD3</p>
<p>Linux内核源代码情景分析</p>

        </div>

        
        
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Yuanye Ma</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2019-04-15
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a href="https://github.com/gohugoio/hugoBasicExample" rel="noopener" target="_blank">See origin</a></span>
  </p>
</div>



        
        


        <footer class="post-footer">
          <div class="post-tags">
              <a href="http://0.0.0.0:1313/tags/kernel-memory-manager/">Kernel memory manager</a>
                
            </div>


          
          <nav class="post-nav">
            
              <a class="prev" href="/post/os/linux-kernel/linux-%E5%86%85%E6%A0%B8%E4%B8%B4%E6%97%B6%E9%A1%B5%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">Linux 内核临时页表初始化</span>
                <span class="prev-text nav-mobile">Prev</span>
              </a>
            
              <a class="next" href="/post/os/linux-kernel/%E5%85%B3%E4%BA%8E%E8%AE%BE%E5%A4%87%E6%A0%91/">
                <span class="next-text nav-default">Linux设备树</span>
                <span class="prev-text nav-mobile">Next</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      


      
      


    </div>

    
    <nav class="toc" id="toc">
    <div class="toc-title">Table of Contents</div>
    <div class="toc-content custom-scrollbar">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#0xfftypora-copy-images-to-">0xFFtypora-copy-images-to: ./</a></li>
  </ul>

  <ul>
    <li><a href="#内存寻址的基本框架">内存寻址的基本框架</a></li>
    <li><a href="#地址映射全过程">地址映射全过程</a>
      <ul>
        <li><a href="#段式映射机制">段式映射机制</a></li>
        <li><a href="#页式映射机制">页式映射机制</a></li>
      </ul>
    </li>
    <li><a href="#几个重要的数据结构">几个重要的数据结构</a>
      <ul>
        <li><a href="#pgd_t--pmd_t--pte_t">pgd_t / pmd_t / pte_t</a></li>
        <li><a href="#struct-page"><code>struct page</code></a></li>
        <li><a href="#struct-zone"><code>struct zone</code></a></li>
        <li><a href="#pg_data_t-或者-struct-pglist_data-"><code>pg_data_t</code> 或者 <code>struct pglist_data </code></a></li>
        <li><a href="#struct-vm_area_struct"><code>struct vm_area_struct</code></a></li>
        <li><a href="#struct-mm_struct"><code>struct mm_struct</code></a></li>
      </ul>
    </li>
    <li><a href="#内存管理基本框架">内存管理基本框架</a></li>
    <li><a href="#伙伴系统">伙伴系统</a></li>
    <li><a href="#slab系统">slab系统</a>
      <ul>
        <li><a href="#slab分配器的接口">slab分配器的接口</a></li>
        <li><a href="#slab系统申请页框">slab系统申请页框</a></li>
        <li><a href="#给高速缓存分配slab">给高速缓存分配slab</a></li>
      </ul>
    </li>
    <li><a href="#全文参考">全文参考</a></li>
  </ul>
</nav>
    </div>
  </nav>


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  
  
    <a href="yuanye.ma@qq.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/YuanyeMa" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.zhihu.com/people/mr-kevin-92" rel="me noopener" class="iconfont"
      title="zhihu"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M351.791182 562.469462l192.945407 0c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262l159.282726 0c0 0-0.86367-67.402109-18.578124-67.402109s-279.979646 0-279.979646 0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461c-4.536316 12.313443 24.62791 5.832845 36.941354 0 12.313443-5.832845 68.050885-25.924439 84.252893-103.69571l86.570681 0c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262L109.86113 490.530013c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449L279.868105 562.469462c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513 0 0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-0.055259 0.185218 167.855986 193.263655c0 0 22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-0.045025 0.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"></path>
  <path d="M584.918753 182.033893l0 668.840094 70.318532 0 28.807093 80.512708 121.875768-80.512708 153.600307 0L959.520453 182.033893 584.918753 182.033893zM887.150192 778.934538l-79.837326 0-99.578949 65.782216-23.537066-65.782216-24.855084 0L659.341766 256.673847l227.807403 0L887.149169 778.934538z"></path>
</svg>

    </a>
  
    <a href="https://space.bilibili.com/159072924?spm_id_from=333.1007.0.0" rel="me noopener" class="iconfont"
      title="bilibili"  target="_blank"
      >
      <svg
  class="icon" style="" viewBox="0 0 1024 1024" version="1.1" width="36"
  height="36" id="svg8">
  <path
      style=""
      d="M 744.60599,0.00486267 A 41.779915,41.779915 0 0 0 710.4184,18.673394 L 548.5048,255.32642 h -11.70046 a 41.779915,41.779915 0 0 0 -10.80295,-7.84928 L 235.66,97.084498 a 41.779915,41.779915 0 0 0 -20.07193,-4.960864 41.779915,41.779915 0 0 0 -18.3748,79.145436 L 359.4859,255.32642 H 128.16909 c -49.458302,0 -89.27932,39.82105 -89.27932,89.27932 v 508.65224 c 0,49.4583 39.821018,89.27934 89.27932,89.27934 h 19.48445 C 149.12802,984.5043 179.92773,1024 224.79179,1024 c 44.86407,0 75.66379,-39.4957 77.13826,-81.46268 H 719.98116 C 721.45559,984.5043 752.25533,1024 797.1194,1024 c 44.86406,0 75.6638,-39.4957 77.13824,-81.46268 h 21.57323 c 49.45831,0 89.27936,-39.82104 89.27936,-89.27934 V 344.60574 c 0,-49.45827 -39.82105,-89.27932 -89.27936,-89.27932 H 649.74567 L 779.38103,65.866924 A 41.779915,41.779915 0 0 0 744.60599,0.00486267 Z M 644.49108,418.70871 c 6.29985,0.21538 12.44451,2.01107 17.86888,5.22196 l 171.36218,98.10771 c 18.23417,10.21935 24.63334,33.34627 14.24614,51.48533 -10.38726,18.13909 -33.57344,24.32718 -51.61587,13.77296 L 624.9903,489.18895 c -15.21356,-8.41858 -22.66871,-26.1765 -18.03211,-42.93436 4.63664,-16.75784 20.15573,-28.14465 37.53289,-27.54588 z M 350.2006,432.31846 c 16.89952,0.0317 31.69582,11.33328 36.17844,27.62747 4.48262,16.2942 -2.44981,33.57765 -16.95507,42.24898 l -140.7157,86.91312 c -17.68528,11.18244 -41.09629,5.77692 -52.08912,-12.02686 -10.99282,-17.80373 -5.33855,-41.15658 12.58167,-51.95857 L 329.9002,438.2095 c 6.0643,-3.86439 13.10951,-5.90891 20.3004,-5.89104 z M 501.605,641.53985 c 3.75002,-0.15248 7.48645,0.53903 10.93349,2.0235 0.15842,0.0637 0.31618,0.12888 0.47325,0.19582 0.59328,0.27092 1.17574,0.56489 1.74609,0.88121 0.15868,0.0854 0.31643,0.17233 0.47325,0.2611 0.55694,0.32165 1.10131,0.66458 1.63185,1.02807 0.16455,0.1123 0.32777,0.2265 0.48956,0.34269 0.50382,0.36781 0.99371,0.75428 1.46868,1.15864 0.18724,0.15504 0.37218,0.31282 0.55484,0.47323 0.43271,0.38784 0.8518,0.79061 1.25653,1.20756 0.15449,0.16114 0.30679,0.32437 0.45693,0.48959 0.40798,0.44266 0.79989,0.89988 1.17494,1.37076 0.17799,0.22544 0.35205,0.45395 0.5222,0.68538 0.25932,0.34701 0.50964,0.70071 0.75064,1.06071 0.26712,0.39516 0.52286,0.79784 0.76699,1.20757 0.16907,0.29043 0.33231,0.58424 0.48957,0.88123 0.21836,0.41297 0.42513,0.83199 0.62009,1.25653 0.14836,0.32333 0.28983,0.64976 0.42429,0.97911 0.21319,0.51552 0.40915,1.03801 0.58747,1.5666 0.0677,0.19499 0.13296,0.39085 0.19582,0.58748 0.18652,0.60823 0.34984,1.22334 0.48957,1.84399 0.0397,0.16277 0.0779,0.32601 0.11423,0.48957 0.1436,0.69112 0.25788,1.38801 0.34269,2.08877 0.005,0.0381 0.0111,0.0761 0.0163,0.11424 0.0857,0.78056 0.13474,1.56471 0.14687,2.34988 0.005,0.0543 0.0111,0.10879 0.0163,0.1632 0,0 -0.008,1.12132 0,1.45234 0,0 -0.14697,17.84761 5.89102,34.12231 3.01902,8.13734 7.33278,15.10615 12.61433,19.61501 5.28157,4.50889 11.42894,7.62081 23.64572,7.62081 12.2168,0 18.36416,-3.11192 23.64573,-7.62081 5.28154,-4.50886 9.5953,-11.47767 12.6143,-19.61501 6.03799,-16.2747 5.89103,-34.12231 5.89103,-34.12231 -0.44885,-13.87045 10.45922,-25.46302 24.3311,-25.86506 13.87189,-0.40201 25.42828,10.53953 25.78348,24.41272 0,0 1.11929,25.7226 -9.00791,53.01927 -5.06359,13.64832 -13.1986,28.46036 -27.05631,40.29073 -13.85772,11.83039 -33.5454,19.63135 -56.20142,19.63135 -22.65603,0 -42.34371,-7.80096 -56.20141,-19.63135 -4.1801,-3.56856 -7.78733,-7.42433 -10.99878,-11.42303 -3.21235,4.00037 -6.81703,7.85309 -10.99876,11.42303 -13.85773,11.83039 -33.5454,19.63135 -56.20144,19.63135 -22.65601,0 -42.3437,-7.80096 -56.2014,-19.63135 -13.85775,-11.83037 -21.99272,-26.64241 -27.05632,-40.29073 -10.12725,-27.29667 -9.00789,-53.01928 -9.00789,-53.01927 0.20714,-13.83687 11.58744,-24.88848 25.42444,-24.69013 14.1263,0.19991 25.2971,12.0278 24.69011,26.14247 0,0 -0.14697,17.84761 5.89103,34.12231 3.01902,8.13734 7.31646,15.10615 12.598,19.61501 5.28155,4.50889 11.44526,7.62081 23.66203,7.62081 12.21681,0 18.36418,-3.11192 23.64573,-7.62081 5.28154,-4.50886 9.57899,-11.47767 12.598,-19.61501 5.76352,-15.53489 5.89112,-32.05691 5.89103,-33.56746 0.006,-0.37466 0.0111,-1.05336 0.0163,-1.20759 -0.0117,-0.74583 0.0105,-1.49177 0.0652,-2.23565 0.009,-0.15784 0.0204,-0.31561 0.0327,-0.47324 0.14204,-1.56859 0.43163,-3.12027 0.86487,-4.63449 0.0213,-0.0763 0.0433,-0.15244 0.0652,-0.22848 3.0335,-10.25748 12.24157,-17.46007 22.92769,-17.93417 z"
      id="rect824"/>
</svg>

    </a>


<a href="http://0.0.0.0:1313/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2024
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Yuanye Ma
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script type="text/javascript" src="/lib/jquery/jquery-3.7.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.823efc68a3fe47916871970a683c47e53fce8735cd7c97764a761f2043c82f7e.js" integrity="sha256-gj78aKP&#43;R5FocZcKaDxH5T/OhzXNfJd2SnYfIEPIL34=" crossorigin="anonymous"></script>



  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>










  
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  

















  </body>
</html>
