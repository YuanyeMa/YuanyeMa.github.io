<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>linux kernel slab系统 - Yuanye Ma's Blog
</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="Yuanye Ma"><meta name=description content="linux kernel slab系统 基于linux kernel v2.6.30.4 基本原理 ​ 以字节为单位的内存管理 ​ SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.125.4"><link rel=canonical href=/post/os/linux-kernel/linux-kernel-slab%E7%B3%BB%E7%BB%9F/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.e826e860368147e5a6685e686355e4d7789023c18c9ea2e78b35f6786ce92736.css integrity="sha256-6CboYDaBR+WmaF5oY1Xk13iQI8GMnqLnizX2eGzpJzY=" media=screen crossorigin=anonymous><meta property="og:url" content="/post/os/linux-kernel/linux-kernel-slab%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="Yuanye Ma's Blog"><meta property="og:title" content="linux kernel slab系统"><meta property="og:description" content="linux kernel slab系统 基于linux kernel v2.6.30.4 基本原理 ​ 以字节为单位的内存管理 ​ SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-04-15T16:01:23+08:00"><meta property="article:modified_time" content="2019-04-15T16:01:23+08:00"><meta property="article:tag" content="Kernel Memory Manager"><meta property="article:tag" content="Slab"><meta itemprop=name content="linux kernel slab系统"><meta itemprop=description content="linux kernel slab系统 基于linux kernel v2.6.30.4 基本原理 ​ 以字节为单位的内存管理 ​ SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是"><meta itemprop=datePublished content="2019-04-15T16:01:23+08:00"><meta itemprop=dateModified content="2019-04-15T16:01:23+08:00"><meta itemprop=wordCount content="19183"><meta itemprop=keywords content="Kernel Memory Manager,Slab"><meta name=twitter:card content="summary"><meta name=twitter:title content="linux kernel slab系统"><meta name=twitter:description content="linux kernel slab系统 基于linux kernel v2.6.30.4 基本原理 ​ 以字节为单位的内存管理 ​ SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=back-to-top></div><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>功不唐捐</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>功不唐捐</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight wallpaper"><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>linux kernel slab系统</h1><div class=post-meta><div class=post-meta-author>by
<a href=/about><span class=post-meta-author-name>Yuanye Ma</span></a></div><div class=post-meta-time><time datetime=2019-04-15>2019-04-15</time></div><div class=post-meta__right><div class=post-meta-category><a href=/categories/linux-kernel/>Linux Kernel</a></div></div></div></header><div class=post-content><h1 id=linux-kernel-slab系统>linux kernel slab系统</h1><p>基于linux kernel v2.6.30.4</p><h2 id=基本原理>基本原理</h2><p>​ 以字节为单位的内存管理
​ SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是：每次释放掉某个对象之后，不是立即将其返回给伙伴系统，而是存放在一个叫 array_cache 的结构中，下次要分配的时候就可以直接从这里分配，从而加快了速度。</p><p>slab系统的内存区域主要分为专用和通用，专用指的是用于存放数据结构的，通用主要指<code>kmalloc</code>用于通用目的而分配的内存。</p><p><img alt=image-20201227201452112 src=/post/os/linux-kernel/linux-kernel-slab%E7%B3%BB%E7%BB%9F/image-20201227201452112.png></p><h2 id=概念以及数据结构>概念以及数据结构</h2><h3 id=struct-kmem_cache><code>struct kmem_cache</code></h3><p>“高速缓存” 其实是一个管理slab的结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * DEBUG        - 1 for kmem_cache_create() to honour; SLAB_RED_ZONE &amp; SLAB_POISON.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                0 for faster, smaller code (especially in the critical paths).
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * STATS        - 1 to collect stats for /proc/slabinfo.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                0 for faster, smaller code (especially in the critical paths).
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * FORCED_DEBUG - 1 enables SLAB_RED_ZONE and SLAB_POISON (if possible)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct kmem_cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * manages a cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> kmem_cache {
</span></span><span style=display:flex><span><span style=color:#75715e>/* 1) per-cpu data, touched during every alloc/free */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span>array[NR_CPUS];
</span></span><span style=display:flex><span><span style=color:#75715e>/* 2) Cache tunables. Protected by cache_chain_mutex */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> batchcount;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> limit;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> shared;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> buffer_size;
</span></span><span style=display:flex><span>        u32 reciprocal_buffer_size;
</span></span><span style=display:flex><span><span style=color:#75715e>/* 3) touched by every alloc &amp; free from the backend */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags;             <span style=color:#75715e>/* constant flags */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> num;               <span style=color:#75715e>/* # of objs per slab */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 4) cache_grow/shrink */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* order of pgs per slab (2^n) */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfporder;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* force GFP flags, e.g. GFP_DMA */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>gfp_t</span> gfpflags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>size_t</span> colour;                  <span style=color:#75715e>/* cache colouring range */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> colour_off;        <span style=color:#75715e>/* colour offset */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>slabp_cache;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> slab_size;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> dflags;            <span style=color:#75715e>/* dynamic flags */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* constructor func */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>ctor)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>obj);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 5) cache creation/removal */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> list_head next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 6) statistics */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if STATS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> num_active;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> num_allocations;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> high_mark;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> grown;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> reaped;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> errors;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> max_freeable;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> node_allocs;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> node_frees;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> node_overflow;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>atomic_t</span> allochit;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>atomic_t</span> allocmiss;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>atomic_t</span> freehit;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>atomic_t</span> freemiss;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * If debugging is enabled, then the allocator can add additional
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * fields and/or padding to every object. buffer_size contains the total
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * object size including these internal fields, the following two
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * variables contain the offset to the user object and its size.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> obj_offset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> obj_size;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * We put nodelists[] at the end of kmem_cache, because we want to size
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * this array to nr_node_ids slots instead of MAX_NUMNODES
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * (see kmem_cache_init())
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * is statically defined, so we reserve the max number of nodes.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>nodelists[MAX_NUMNODES];
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Do not add fields after nodelists[]
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=本地cpu空闲对象链表>本地CPU空闲对象链表</h3><p><code>struct kmem_cache</code>中定义了一个 <code>struct array_cache</code>结构体指针数组，即成员<code>struct array_cache *array[NR_CPUS];</code>，数组的元素个数对应了系统的CPU数。和伙伴系统的每CPU页框高速缓存类似，该结构用来描述每个CPU的本地高速缓存，在每个<code>array_cache</code>的末端，都用一个指针数组记录了slab中的空闲对象。分配对象的时候采用LIFO方式，也就是将该数组中的最后一个索引对应的对象分配出去。实际上，每次分配内存都是直接与本地CPU高速缓存进行交互，只有当其空闲内存不足时，才会从<code>kmem_list3</code>中的slab中取一些加入到本地高速缓存中。</p><blockquote><p>本地CPU空闲对象链表，存在的意义：</p><p>每个CPU都有它自己的硬件缓存（L1 L2 Cache），当此CPU上释放对象时，这个对象很可能还在CPU Cache中，所以内核为每个CPU维护这样一个链表，当需要新的对象时，会优先尝试从当前CPU的“pre-cpu”缓存中空闲对象列表获取相应大小的对象。</p><p>减少所的竞争，假设多个CPU同时申请一个大小的slab，这时如果没有"pre-cpu"缓存空闲对象链表，就会导致分配的流程互斥，需要上锁，这就导致分配效率低下。而如果分配对象时从各自的CPU缓存中分配就不会出现竞争问题。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct array_cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Purpose:
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - LIFO ordering, to hand out cache-warm objects from _alloc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - reduce the number of linked list operations
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - reduce spinlock operations
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The limit is stored in the per-cpu structure to reduce the data cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> * footprint.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> array_cache {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> avail; <span style=color:#75715e>/* 可用对象数目 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> limit; <span style=color:#75715e>/* 可拥有的最大对象数目，和kmem_cache中一样 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> batchcount; <span style=color:#75715e>/* 同kmem_cache，要转移进本地高速缓存或从本地高速缓存中转移出去的对象的个数 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> touched; <span style=color:#75715e>/* 是否在收缩后被访问过 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>spinlock_t</span> lock;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>entry[];  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * Must have this definition in here for the proper
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * alignment of array_cache. Also simplifies accessing
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * the entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* entry是一个伪数组，初始没有任何数据项，之后会增加并保存释放的对象指针 */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个本地CPU空闲对象链表在初始化完成后是一个空的链表，只有释放对象时才会将对象加入这个链表。链表中对象的个数受<code>limit</code>字段限制，其最大值就是<code>limit</code>。链表中对象个数超过这个值时，会将<code>batchcount</code>个对象返回到所有CPU共享的空闲对象链表（也是这样一个结构）中。</p><p><code>array_cache</code>中的<code>entry</code>数组保存的是指向空闲对象的首地址的指针，此链表是在<code>kmem_cache</code>结构中的，<strong>即每一种类型的<code>kmem_cache</code>都有它自己的本地CPU空闲对象链表</strong>。</p><h3 id=所有cpu共享的空闲对象链表>所有CPU共享的空闲对象链表</h3><p>原理和本地CPU空闲对象列表是一样的，唯一的区别就是所有CPU都可以从这个链表中获取对象。所有CPU共享的空闲对象链表不是一直都有，而是根据<code>kmem_cache</code>的<code>shared</code>字段确定，如果<code>shared</code>为1，则此<code>kmem_cache</code>中存在此链表，否则不存在。</p><p>一个常规的对象申请流程：系统首先会从本地CPU空闲对象链表中尝试获取一个对象用于分配；如果失败，则尝试从所有CPU共享的空闲对象列表中尝试获取；如果还是失败，就会从SLAB中分配一个；这时如果还失败<code>kmem_cache</code>会尝试从页框分配器中获取一组连续页框，建立一个新的slab，然后将从新的slab中获取一个对象。</p><p>对象释放流程也类似：首先将对象释放到本地CPU空闲对象链表，如果本地CPU空闲对象链表中的对象过多（大于limit），<code>kmem_cache</code>会将本地CPU空闲对象链表中的<code>batchcount</code>个对象移动到所有CPU共享的空闲对象链表中，如果所有CPU共享的空闲对象链表中的对象数量也超过了limit，<code>kmem_cache</code>会把所有CPU共享的空闲对象链表中的<code>batchcount</code>个对象移回他们自己所属的SLAB中，这是如果SLAB中空闲对象也太多了，<code>kmem_cache</code>会整理出一些空闲的slab，将这些slab占用的页框释放回页框分配器中。</p><h3 id=struct-kmem_list3><code>struct kmem_list3</code></h3><p>每个内存结点都有自己的<code>kmem_list3</code>，每个CPU都有<code>array_cache</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The slab lists for all objects.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> kmem_list3 {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> list_head slabs_partial; <span style=color:#75715e>/* partial list first, better asm code */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> list_head slabs_full;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> list_head slabs_free;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> free_objects;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> free_limit;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> colour_next;       <span style=color:#75715e>/* Per-node cache coloring */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>spinlock_t</span> list_lock;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span>shared;     <span style=color:#75715e>/* shared per node */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>**</span>alien;     <span style=color:#75715e>/* on other nodes */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> next_reap;        <span style=color:#75715e>/* updated without locking */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> free_touched;               <span style=color:#75715e>/* updated without locking */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=sturct-slab><code>sturct slab</code></h3><p>负责管理从buddy系统分配的一个或多个物理页框，slab主要包含两大部分，管理性数据和obj对象，其中管理性数据包括<code>struct slab</code>和<code>kmem_bufctl_t</code>。</p><p>slab有两种形式的结构：管理数据外挂或者内嵌。如果obj较小，那么<code>struct slab</code>和<code>kmem_bufctl_t</code>可以和obj分配在同一个物理页中，称为内嵌。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_bufctl_t:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Bufctl&#39;s are used for linking objs within a slab
</span></span></span><span style=display:flex><span><span style=color:#75715e> * linked offsets.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This implementation relies on &#34;struct page&#34; for locating the cache &amp;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * slab an object belongs to.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This allows the bufctl structure to be small (one int), but limits
</span></span></span><span style=display:flex><span><span style=color:#75715e> * the number of objects a slab (not a cache) can contain when off-slab
</span></span></span><span style=display:flex><span><span style=color:#75715e> * bufctls are used. The limit is the size of the largest general cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> * that does not use off-slab slabs.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * For 32bit archs with 4 kB pages, is this 56.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This is not serious, as it is only for large objects, when it is unwise
</span></span></span><span style=display:flex><span><span style=color:#75715e> * to have too many per slab.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Note: This limit can be raised by introducing a general cache whose size
</span></span></span><span style=display:flex><span><span style=color:#75715e> * is less than 512 (PAGE_SIZE&lt;&lt;3), but greater than 256.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>kmem_bufctl_t</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#define BUFCTL_END      (((kmem_bufctl_t)(~0U))-0)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BUFCTL_FREE     (((kmem_bufctl_t)(~0U))-1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BUFCTL_ACTIVE   (((kmem_bufctl_t)(~0U))-2)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SLAB_LIMIT      (((kmem_bufctl_t)(~0U))-3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct slab
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Manages the objs in a slab. Placed either at the beginning of mem allocated
</span></span></span><span style=display:flex><span><span style=color:#75715e> * for a slab, or allocated from an general cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Slabs are chained into three list: fully used, partial, fully free slabs.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> slab {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> list_head list;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> colouroff;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>s_mem;            <span style=color:#75715e>/* including colour offset 指向第一个对象的地址 */</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> inuse;     <span style=color:#75715e>/* num of objs active in slab */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>kmem_bufctl_t</span> free;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> nodeid;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><img alt=kmem_bufctl_t src=https://img-blog.csdn.net/2018041716304834?watermark/2/text/aHR0cHM6Ly9ibG9nLmN></p><p><img alt=kmem_bufctl_t src=https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/TB000008.png></p><p>在每个 slab 中，起始处是为着色预留的区间，接下来是<code> struct slab</code> 结构，该结构就是用于管理 slab 的数据，紧接着就是一个 <code>kmem_bufctl</code>数组，该数组是由 <code>kmem_bufctl_t</code> 类型的成员组成的数组。接下来是对象区，这就是用于分配的对象。 在 <code>kmem_bufctl</code> 数组中，每个成员按顺序与每个对象进行绑定，用于表示该对象的下 一个对象的索引，并且最后一个对象的值为 <code>BUFCTL_END</code>, 这样将 slab 中的所有对象通过一个单链表进行维护。通过上面的分析，<code>kmem_bufctl_t</code> 数据结构构造的数据用于指向当前对象指向的下一个对象的索引.</p><p><img alt=slab src=https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/TB000007.png></p><p>在 SLAB 分配器中，struct slab 可以位于 slab 内部，也可以位于 slab 外部，但 不论位于 slab 内部或外部，其成员的含义都是一致的。colouroff 成员用于指明该 slab 着色总长度，其包含了着色、struct slab 以及 kmem_bufctl array 的总长度， 这样可用对象加载到 CACHE 之后就会被插入到不同的 CACHE 行; s_mem 用于指向 slab 中对象的起始地址; inuse 成员用于指定 slab 中可用对象的数量; free 成员 用于指向 slab 当前可用对象在 kmem_bufctl 的索引; nodeid 成员用于指向该 slab 位于哪个 NODE; list 成员用于将 slab 加入到 struct kmem_cache 的 kmem_list3 中三个链表中的其中一个链表。</p><h3 id=object>object</h3><p>每个slab只负责管理一种类型的“对象”， 将该大小进行内存对齐后的大小就是该“对象”的大小，依此大小对slab进行划分，从而实现细粒度的内存管理</p><h3 id=结构之间的关系>结构之间的关系</h3><p><img alt=Memery_Layout_14 src=http://chenweixiang.github.io/assets/Memery_Layout_14.jpg></p><p><code>cache_chain</code>的定义：<code>static struct list_head cache_chain;</code>是一个<code>struct kmem_cache</code>的链表，将所有<code>struct kemem_cache</code>连接起来。</p><p><code>cache_cache</code>是第一个<code>kemem_cache_struct</code>结构，通过<code>struct kmem_list3</code>结构维护的三个<code>struct slab</code>链表构成了内核的第一个<code>slab</code>系统，用于存储<code>slab</code>系统所有的<code>struct kmem_cache_struct</code>结构。</p><p><code>struct slab</code>结构可以通过参数选择1.存储在自己<code>slab</code>管理的页面上，2.存储到<code>cache_cache</code>中?</p><p><code>struct kmem_list3</code>结构存在哪里？</p><p><img alt=结构 src=https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/TB000001.png></p><h3 id=参考资料>参考资料</h3><p><a href=http://blog.chinaunix.net/uid-31562863-id-5793195.html>Linux内存管理之slab分配器分析(一)</a></p><p><a href=https://blog.csdn.net/rockrockwu/article/details/79976833>Linux内存管理之SLAB原理浅析</a></p><p><a href=https://www.cnblogs.com/tolimit/p/4566189.html>linux内存源码分析 - SLAB分配器概述</a></p><h2 id=kmem_cache_init>kmem_cache_init</h2><p>此函数在<code>init/main.c</code>中被<code>start_kernel()</code>函数调用，其定义在<code>mm/slab.c</code>中定义。先看看源码中的注释： 引导程序很棘手，因为需要从尚不存在的caches中分配几个objects。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Initialisation.  Called after the page allocator have been initialised and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * before smp_init().
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>kmem_cache_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Bootstrap is tricky, because several objects are allocated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * from caches that do not exist yet:
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 1) initialize the cache_cache cache: it contains the struct
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    kmem_cache structures of all caches, except cache_cache itself:
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    cache_cache is statically allocated.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    Initially an __init data area is used for the head array and the
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    kmem_list3 structures, it&#39;s replaced with a kmalloc allocated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    array at the end of the bootstrap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2) Create the first kmalloc cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    The struct kmem_cache for the new cache is allocated normally.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    An __init data area is used for the head array.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 3) Create the remaining kmalloc caches, with minimally sized
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    head arrays.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 4) Replace the __init data head arrays for cache_cache and the first
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    kmalloc cache with kmalloc allocated arrays.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 5) Replace the __init data for kmem_list3 for cache_cache and
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *    the other cache&#39;s with kmalloc allocated memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 6) Resize the head arrays of the kmalloc caches to their final sizes.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从注释可以看出，<code>kmem_cache_init()</code>函数主要完成六项工作：</p><ol><li><p>初始化<code>cache_cache</code>高速缓存：静态分配<code>cache_cache</code>结构，它用于保存所有高速缓存的<code>struct kmem_cache</code>描述结构体。初始化一个<code>__init</code>数据区域，用于保存<code>head array</code>和<code>kmem_list3</code>结构体，在引导程序末尾将其替换为<code>kmalloc</code>分配的数组。</p></li><li><p>创建第一个<code>kmalloc</code>用的<code>cache</code>:</p></li><li><p>创建剩余的<code>kmalloc</code>缓存，并使用最小大小的头数组。</p></li><li><p>将<code>cache_cache</code>的<code>__init</code>数据头数组和第一个<code>kmalloc</code>缓存替换为<code>kmalloc</code>分配的数组。</p></li><li><p>将<code>kmem_list3</code>的<code>__init</code>数据替换为<code>cache_cache</code>，将其他缓存替换为<code>kmalloc</code>分配的内存。</p></li><li><p>将<code>kmalloc</code>缓存的头数组调整为最终大小。</p></li></ol><pre tabindex=0><code>(1)构建好了kmem_cache实例cache_cache(静态分配)，且构建好了kmem_cache的slab分配器,并由initkmem_list3[0]组织, 相应的array为initarray_cache；
(2)构建好了kmem_cache实例（管理arraycache_init），且构建好了arraycache_init的slab分配器,并由initkmem_list3[1]组织,相应的array为initarray_generic；
(3)构建好了kmem_cache实例（管理kmem_list3）,此时还未构建好kmem_list3的slab分配器，但是一旦申请sizeof(kmem_list3)空间，将构建kmem_list3分配器,并由initkmem_list[2]组织,其array将通过kmalloc进行申请；
(4)为malloc_sizes的相应数组元素构建kmem_cache实例，并分配kmem_list3,用于组织slab链表，分配arraycache_init用于组织每CPU的同一个kmem_cache下的slab分配;
(5)替换kmem_cache、malloc_sizes[INDEX_AC].cs_cachep下的arraycache_init实例；
(6)替换kmem_cache、malloc_sizes[INDEX_AC].cs_cachep、malloc_sizes[INDEX_L3].cs_cachep下的kmem_list3实例;
(7)g_cpucachep_up = EARLY;
</code></pre><p>在slab初始化好之前，无法通过kmalloc分配初始化过程中必要的一些对象，只能使用静态的全局变量，待slab初始化后期，再使用kmalloc动态分配的对象替换全局变量</p><h3 id=初始化前的准备工作>初始化前的准备工作</h3><p>静态全局变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * bootstrap: The caches do not work without cpuarrays anymore, but the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * cpuarrays are allocated from the generic caches...
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BOOT_CPUCACHE_ENTRIES   1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> arraycache_init {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache cache;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>entries[BOOT_CPUCACHE_ENTRIES];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> arraycache_init initarray_cache __initdata <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    { {<span style=color:#ae81ff>0</span>, BOOT_CPUCACHE_ENTRIES, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>} };
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> arraycache_init initarray_generic <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    { {<span style=color:#ae81ff>0</span>, BOOT_CPUCACHE_ENTRIES, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>} };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>即</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> arraycache_init initarray_generic <span style=color:#f92672>=</span> initarray_cache.cache <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> array_cache {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> avail <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>/* 可用对象数目 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> limit <span style=color:#f92672>=</span> BOOT_CPUCACHE_ENTRIES; <span style=color:#75715e>/* 可拥有的最大对象数目，和kmem_cache中一样 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> batchcount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* 同kmem_cache，要转移进本地高速缓存或从本地高速缓存中转移出去的对象的个数 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> touched <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>/* 是否在收缩后被访问过 */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>slab系统三个最重要的结构体，<code>kmem_cache</code> <code>arary_cache</code> 以及 <code>kmem_list3</code>，初始化slab系统，其实就是初始化这三个结构体， 在slab系统初始化的初期，slab系统还没建立起来，只能通过静态全局变量初始化这三个结构体，用以搭建一个初始化阶段用的临时slab系统，等slab系统建立起来后，再将这三个结构体加入到slab系统管理的内存中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>kmem_cache_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>        如前所述，先借用全局变量initkmem_list3表示的slab三链 ，每个内存节点对应一组slab三链。
</span></span></span><span style=display:flex><span><span style=color:#75715e>        initkmem_list3是个slab三链数组，包含所有内存节点的slab三链。
</span></span></span><span style=display:flex><span><span style=color:#75715e>        对于每个内存节点，包含三个三链： 
</span></span></span><span style=display:flex><span><span style=color:#75715e>            struct kmem_cache的slab三链、
</span></span></span><span style=display:flex><span><span style=color:#75715e>            struct arraycache_init的slab 三链、
</span></span></span><span style=display:flex><span><span style=color:#75715e>            struct kmem_list3的slab三链 
</span></span></span><span style=display:flex><span><span style=color:#75715e>        这里循环初始化所有内存节点的所有slab三链 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NUM_INIT_LISTS; i<span style=color:#f92672>++</span>) { <span style=color:#75715e>/* 每个内存结点都有kmem_list3 */</span>
</span></span><span style=display:flex><span>              	<span style=color:#75715e>/*初始化所有node的所有slab中的三个链表*/</span>  
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>kmem_list3_init</span>(<span style=color:#f92672>&amp;</span>initkmem_list3[i]); <span style=color:#75715e>/* 1 2 */</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* 这里初始化所有内存节点的struct kmem_cache的slab三链为空。*/</span>  
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> MAX_NUMNODES)
</span></span><span style=display:flex><span>                        cache_cache.nodelists[i] <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>set_up_list3s</span>(<span style=color:#f92672>&amp;</span>cache_cache, CACHE_CACHE); <span style=color:#75715e>/* 3 4 */</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Fragmentation resistance on low memory - only use bigger
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * page orders on machines with more than 32MB of memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (num_physpages <span style=color:#f92672>&gt;</span> (<span style=color:#ae81ff>32</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>20</span>) <span style=color:#f92672>&gt;&gt;</span> PAGE_SHIFT)
</span></span><span style=display:flex><span>                slab_break_gfp_order <span style=color:#f92672>=</span> BREAK_GFP_ORDER_HI;
</span></span></code></pre></div><p>主要两个函数起作用：<code>kmem_list3_init()</code>和<code>set_up_list3s</code>;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 1.关于全局变量initkmem_list3的定义，以及宏NUM_INIT_LISTS的定义 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Need this for bootstrapping a per node allocator.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_INIT_LISTS (3 * MAX_NUMNODES)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> kmem_list3 __initdata initkmem_list3[NUM_INIT_LISTS];   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* include/linux/numa.h */</span>    
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_NODES_SHIFT 
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NODES_SHIFT     CONFIG_NODES_SHIFT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NODES_SHIFT     0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX_NUMNODES    (1 &lt;&lt; NODES_SHIFT)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	总结 ： 一个UMA系统中只有一个Node，而在NUMA中则可以存在多个Node。它由CONFIG_NODES_SHIFT配置选项决定，它是CONFIG_NUMA的子选项，所以只有配置了CONFIG_NUMA，该选项才起作用。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	UMA情况下，NODES_SHIFT被定义为0，MAX_NUMNODES也即为1。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span><span style=color:#75715e>/* 2. kmem_list3_init()所做的初始化 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>kmem_list3_init</span>(<span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>parent)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>INIT_LIST_HEAD</span>(<span style=color:#f92672>&amp;</span>parent<span style=color:#f92672>-&gt;</span>slabs_full);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>INIT_LIST_HEAD</span>(<span style=color:#f92672>&amp;</span>parent<span style=color:#f92672>-&gt;</span>slabs_partial);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>INIT_LIST_HEAD</span>(<span style=color:#f92672>&amp;</span>parent<span style=color:#f92672>-&gt;</span>slabs_free);
</span></span><span style=display:flex><span>        parent<span style=color:#f92672>-&gt;</span>shared <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        parent<span style=color:#f92672>-&gt;</span>alien <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        parent<span style=color:#f92672>-&gt;</span>colour_next <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock_init</span>(<span style=color:#f92672>&amp;</span>parent<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>        parent<span style=color:#f92672>-&gt;</span>free_objects <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        parent<span style=color:#f92672>-&gt;</span>free_touched <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 3. 全局变量cache_cache的初始化 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* internal cache of cache description objs */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> kmem_cache cache_cache <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .batchcount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        .limit <span style=color:#f92672>=</span> BOOT_CPUCACHE_ENTRIES,
</span></span><span style=display:flex><span>        .shared <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#75715e>/* 所有CPU共享的空闲对象链表 */</span>
</span></span><span style=display:flex><span>        .buffer_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> kmem_cache), <span style=color:#75715e>/* kmem_cache中对象的大小 */</span>
</span></span><span style=display:flex><span>        .name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;kmem_cache&#34;</span>, <span style=color:#75715e>/* kmem_cache的名字 */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>/* 4. set_up_list3s(&amp;cache_cache, CACHE_CACHE); */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define CACHE_CACHE 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * For setting up all the kmem_list3s for cache whose buffer_size is same as
</span></span></span><span style=display:flex><span><span style=color:#75715e> * size of kmem_list3.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>set_up_list3s</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>for_each_online_node</span>(node) {
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>nodelists[node] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>initkmem_list3[index <span style=color:#f92672>+</span> node];
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>nodelists[node]<span style=color:#f92672>-&gt;</span>next_reap <span style=color:#f92672>=</span> jiffies <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                    REAPTIMEOUT_LIST3 <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                    ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)cachep) <span style=color:#f92672>%</span> REAPTIMEOUT_LIST3;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	设置struct kmem_cache的slab三链指向initkmem_list3中的一组slab三链， 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    CACHE_CACHE为cache在内核cache链表中的索引， 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    struct kmem_cache对应的cache是内核中创建的第一个cache 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    ，故CACHE_CACHE为0  
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 5.     
</span></span></span><span style=display:flex><span><span style=color:#75715e>	全局变量slab_break_gfp_order为每个slab最多占用几个页面 ，用来抑制碎片。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	如大小为3360的对象，如果其slab只占一个页面，碎片为736，slab占用两个页面，则碎片大小也翻倍。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     只有当对象很大以至于slab中连一个对象都放不下时才可以超过这个值。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     有两个可能的取值 ：
</span></span></span><span style=display:flex><span><span style=color:#75715e>     	当可用内存大于32MB时，BREAK_GFP_ORDER_HI为1 ，即每个slab最多占用2个页面 ，只有当对象大小大于8192时 ，才可以突破slab_break_gfp_order的限制。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     	小于等于32MB时BREAK_GFP_ORDER_LO为0。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=1-初始化cache_chain>1） 初始化<code>cache_chain</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>node <span style=color:#f92672>=</span> <span style=color:#a6e22e>numa_node_id</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>/* 1) create the cache_cache */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>INIT_LIST_HEAD</span>(<span style=color:#f92672>&amp;</span>cache_chain);
</span></span><span style=display:flex><span><span style=color:#a6e22e>list_add</span>(<span style=color:#f92672>&amp;</span>cache_cache.next, <span style=color:#f92672>&amp;</span>cache_chain);
</span></span><span style=display:flex><span>cache_cache.colour_off <span style=color:#f92672>=</span> <span style=color:#a6e22e>cache_line_size</span>();
</span></span><span style=display:flex><span>cache_cache.array[<span style=color:#a6e22e>smp_processor_id</span>()] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>initarray_cache.cache;
</span></span><span style=display:flex><span>cache_cache.nodelists[node] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>initkmem_list3[CACHE_CACHE <span style=color:#f92672>+</span> node];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct kmem_cache size depends on nr_node_ids, which
</span></span></span><span style=display:flex><span><span style=color:#75715e> * can be less than MAX_NUMNODES.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>cache_cache.buffer_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>offsetof</span>(<span style=color:#66d9ef>struct</span> kmem_cache, nodelists) <span style=color:#f92672>+</span> nr_node_ids <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>/*offsetof会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cache_cache.buffer_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(cache_cache.buffer_size, <span style=color:#a6e22e>cache_line_size</span>());
</span></span><span style=display:flex><span>cache_cache.reciprocal_buffer_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>reciprocal_value</span>(cache_cache.buffer_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (order <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; order <span style=color:#f92672>&lt;</span> MAX_ORDER; order<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*计算每个slab中对象的数目。*/</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cache_estimate</span>(order, cache_cache.buffer_size,
</span></span><span style=display:flex><span>                   <span style=color:#a6e22e>cache_line_size</span>(), <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>left_over, <span style=color:#f92672>&amp;</span>cache_cache.num);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cache_cache.num)
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span>cache_cache.num);
</span></span><span style=display:flex><span>cache_cache.gfporder <span style=color:#f92672>=</span> order;
</span></span><span style=display:flex><span>cache_cache.colour <span style=color:#f92672>=</span> left_over <span style=color:#f92672>/</span> cache_cache.colour_off;
</span></span><span style=display:flex><span>cache_cache.slab_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(cache_cache.num <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>kmem_bufctl_t</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> slab), <span style=color:#a6e22e>cache_line_size</span>());
</span></span></code></pre></div><h3 id=23-创建kmalloc用的高速缓存>2）&amp;3） 创建<code>kmalloc</code>用的高速缓存</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 2+3) create the kmalloc caches */</span>
</span></span><span style=display:flex><span>sizes <span style=color:#f92672>=</span> malloc_sizes; <span style=color:#75715e>/* 1 */</span>
</span></span><span style=display:flex><span>names <span style=color:#f92672>=</span> cache_names;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* begin of 2  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Initialize the caches that provide memory for the array cache and the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_list3 structures first.  Without this, further allocations will
</span></span></span><span style=display:flex><span><span style=color:#75715e> * bug.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>sizes[INDEX_AC].cs_cachep <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_create</span>(names[INDEX_AC].name,
</span></span><span style=display:flex><span>                                              sizes[INDEX_AC].cs_size,
</span></span><span style=display:flex><span>                                              ARCH_KMALLOC_MINALIGN,
</span></span><span style=display:flex><span>                                              ARCH_KMALLOC_FLAGS<span style=color:#f92672>|</span>SLAB_PANIC,
</span></span><span style=display:flex><span>                                              NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (INDEX_AC <span style=color:#f92672>!=</span> INDEX_L3) {
</span></span><span style=display:flex><span>    sizes[INDEX_L3].cs_cachep <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem_cache_create</span>(names[INDEX_L3].name,
</span></span><span style=display:flex><span>                          sizes[INDEX_L3].cs_size,
</span></span><span style=display:flex><span>                          ARCH_KMALLOC_MINALIGN,
</span></span><span style=display:flex><span>                          ARCH_KMALLOC_FLAGS<span style=color:#f92672>|</span>SLAB_PANIC,
</span></span><span style=display:flex><span>                          NULL);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* end of 2  */</span>
</span></span><span style=display:flex><span>slab_early_init <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* begin of 3 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (sizes<span style=color:#f92672>-&gt;</span>cs_size <span style=color:#f92672>!=</span> ULONG_MAX) { <span style=color:#75715e>/* ULONG_MAX = (~0UL)即最大值 */</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * For performance, all the general caches are L1 aligned.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * This should be particularly beneficial on SMP boxes, as it
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * eliminates &#34;false sharing&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * Note for systems short on memory removing the alignment will
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * allow tighter packing of the smaller caches.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>sizes<span style=color:#f92672>-&gt;</span>cs_cachep) {
</span></span><span style=display:flex><span>        sizes<span style=color:#f92672>-&gt;</span>cs_cachep <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_create</span>(names<span style=color:#f92672>-&gt;</span>name,
</span></span><span style=display:flex><span>                                             sizes<span style=color:#f92672>-&gt;</span>cs_size,
</span></span><span style=display:flex><span>                                             ARCH_KMALLOC_MINALIGN,
</span></span><span style=display:flex><span>                                             ARCH_KMALLOC_FLAGS<span style=color:#f92672>|</span>SLAB_PANIC,
</span></span><span style=display:flex><span>                                             NULL);
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_ZONE_DMA
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sizes<span style=color:#f92672>-&gt;</span>cs_dmacachep <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_create</span>(names<span style=color:#f92672>-&gt;</span>name_dma,
</span></span><span style=display:flex><span>                                            sizes<span style=color:#f92672>-&gt;</span>cs_size,
</span></span><span style=display:flex><span>                                            ARCH_KMALLOC_MINALIGN,
</span></span><span style=display:flex><span>                                            ARCH_KMALLOC_FLAGS<span style=color:#f92672>|</span>SLAB_CACHE_DMA<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>                                            SLAB_PANIC,
</span></span><span style=display:flex><span>                                            NULL);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sizes<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        names<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#75715e>/* end of 3 */</span>
</span></span></code></pre></div><p>分步骤看看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 1.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> cache_sizes <span style=color:#f92672>*</span>sizes;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> cache_names <span style=color:#f92672>*</span>names;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sizes <span style=color:#f92672>=</span> malloc_sizes; 
</span></span><span style=display:flex><span>names <span style=color:#f92672>=</span> cache_names;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 先看看这两个变量的类型 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Size description struct for general caches. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> cache_sizes {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>size_t</span>                  cs_size;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_cache       <span style=color:#f92672>*</span>cs_cachep;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_ZONE_DMA
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>struct</span> kmem_cache       <span style=color:#f92672>*</span>cs_dmacachep;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span><span style=color:#75715e>/* Must match cache_sizes above. Out of line to keep cache footprint low. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> cache_names {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name_dma;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 然后看看全局变量malloc_sizes和cache_names的定义 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * These are the default caches for kmalloc. Custom caches can have other sizes.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ULONG_MAX       (~0UL)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> cache_sizes malloc_sizes[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#define CACHE(x) { .cs_size = (x) },
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/kmalloc_sizes.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(ULONG_MAX)
</span></span><span style=display:flex><span><span style=color:#75715e>#undef CACHE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(malloc_sizes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> cache_names __initdata cache_names[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#define CACHE(x) { .name = &#34;size-&#34; #x, .name_dma = &#34;size-&#34; #x &#34;(DMA)&#34; },
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/kmalloc_sizes.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        {NULL,}
</span></span><span style=display:flex><span><span style=color:#75715e>#undef CACHE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 其中include/linux/kmalloc_sizes.h的内容如下 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if (PAGE_SIZE == 4096)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#if L1_CACHE_BYTES &lt; 64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>96</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>128</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#if L1_CACHE_BYTES &lt; 128
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>192</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>256</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>512</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>2048</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>4096</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>8192</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>16384</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>32768</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>65536</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>131072</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 262144
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>262144</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 524288
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>524288</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 1048576
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>1048576</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 2097152
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>2097152</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 4194304
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>4194304</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 8388608
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>8388608</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 16777216
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>16777216</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if KMALLOC_MAX_SIZE &gt;= 33554432
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>CACHE</span>(<span style=color:#ae81ff>33554432</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>展开后的定义如下
</span></span></span><span style=display:flex><span><span style=color:#75715e>struct cache_sizes malloc_sizes[] = {
</span></span></span><span style=display:flex><span><span style=color:#75715e> { .cs_size = (32) },
</span></span></span><span style=display:flex><span><span style=color:#75715e> { .cs_size = (64) },
</span></span></span><span style=display:flex><span><span style=color:#75715e> { .cs_size = (128) },
</span></span></span><span style=display:flex><span><span style=color:#75715e> { .cs_size = (256) },
</span></span></span><span style=display:flex><span><span style=color:#75715e> { .cs_size = (512) },
</span></span></span><span style=display:flex><span><span style=color:#75715e>	...
</span></span></span><span style=display:flex><span><span style=color:#75715e> { .cs_size = (~0UL) },
</span></span></span><span style=display:flex><span><span style=color:#75715e>};
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>static struct cache_names __initdata cache_names[] = {
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {.name = &#34;size-32&#34;, .name_dma = &#34;size-32(DMA)&#34;},
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {.name = &#34;size-64&#34;, .name_dma = &#34;size-64(DMA)&#34;},
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {.name = &#34;size-128&#34;, .name_dma = &#34;size-128(DMA)&#34;},
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {.name = &#34;size-256&#34;, .name_dma = &#34;size-256(DMA)&#34;},
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .....
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {NULL,}
</span></span></span><span style=display:flex><span><span style=color:#75715e>};
</span></span></span><span style=display:flex><span><span style=color:#75715e>	即，定义了struct cache_sizes malloc_sizes[]和struct cache_names cache_names[]。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	并将这两个数组的地址赋值给了sizes和namas两个变量。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 2 创建专用的高速缓存*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define INDEX_AC index_of(sizeof(struct arraycache_init))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define INDEX_L3 index_of(sizeof(struct kmem_list3))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*           
</span></span></span><span style=display:flex><span><span style=color:#75715e>	INDEX_AC就是与sizeof(struct arraycache_init :28==&gt;0)适配的kmalloc可分配缓存的索引.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	INDEX_L3就是与sizeof(struct kmem_list3 :56==&gt;1)适配的kmalloc可分配缓存的索引.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>          
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>其中</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * bootstrap: The caches do not work without cpuarrays anymore, but the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * cpuarrays are allocated from the generic caches...
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BOOT_CPUCACHE_ENTRIES   1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> arraycache_init {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache cache;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>entries[BOOT_CPUCACHE_ENTRIES];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	即2这里创建了两个调用kmem_cache_create()函数创建了两个高速缓存。 
</span></span></span><span style=display:flex><span><span style=color:#75715e>		即struct array_cache和struct kmem_list3所用的general cache。
</span></span></span><span style=display:flex><span><span style=color:#75715e>    INDEX_AC是计算local cache所用的struct arraycache_init对象在kmalloc size中的索引 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    ，即属于哪一级别大小的general cache，创建此大小级别的cache为local cache所用。  
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 3 这里是一个循环，循环调用kmem_cache_create()函数，创建剩下的给kmalloc用的高速缓存 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (sizes<span style=color:#f92672>-&gt;</span>cs_size <span style=color:#f92672>!=</span> ULONG_MAX) { <span style=color:#75715e>/* ULONG_MAX = (~0UL)即最大值 */</span>
</span></span><span style=display:flex><span>    sizes<span style=color:#f92672>-&gt;</span>cs_cachep <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_create</span>(names<span style=color:#f92672>-&gt;</span>name, sizes<span style=color:#f92672>-&gt;</span>cs_size, ...);
</span></span><span style=display:flex><span>    sizes<span style=color:#f92672>-&gt;</span>cs_dmacachep <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_create</span>(names<span style=color:#f92672>-&gt;</span>name_dma, sizes<span style=color:#f92672>-&gt;</span>cs_size, ...);
</span></span><span style=display:flex><span>    sizes<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    names<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-用kmalloc对象替换静态分配的全局高速缓存变量>4） 用<code>kmalloc</code>对象替换静态分配的全局高速缓存变量</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 4) Replace the bootstrap head arrays */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	用kmalloc对象替换静态分配的全局变量。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	到目前为止一共使用了两个全局local cache，
</span></span></span><span style=display:flex><span><span style=color:#75715e>		一个是cache_cache的local cache指向initarray_cache.cache; 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    	另一个是malloc_sizes[INDEX_AC].cs_cachep的local cache指向initarray_generic.cache,参见setup_cpu_cache函数。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> arraycache_init), GFP_KERNEL);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 第2)和第3)步已经初始化了kmalloc用的高速缓存，这里可以使用kmalloc函数进行内存分配了 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#a6e22e>cpu_cache_get</span>(<span style=color:#f92672>&amp;</span>cache_cache) <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>initarray_cache.cache);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(ptr, <span style=color:#a6e22e>cpu_cache_get</span>(<span style=color:#f92672>&amp;</span>cache_cache),
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> arraycache_init));
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Do not assume that spinlocks can be initialized via memcpy:
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spin_lock_init</span>(<span style=color:#f92672>&amp;</span>ptr<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cache_cache.array[<span style=color:#a6e22e>smp_processor_id</span>()] <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> arraycache_init), GFP_KERNEL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#a6e22e>cpu_cache_get</span>(malloc_sizes[INDEX_AC].cs_cachep)
</span></span><span style=display:flex><span>           <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>initarray_generic.cache);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(ptr, <span style=color:#a6e22e>cpu_cache_get</span>(malloc_sizes[INDEX_AC].cs_cachep),
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> arraycache_init));
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Do not assume that spinlocks can be initialized via memcpy:
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spin_lock_init</span>(<span style=color:#f92672>&amp;</span>ptr<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    malloc_sizes[INDEX_AC].cs_cachep<span style=color:#f92672>-&gt;</span>array[<span style=color:#a6e22e>smp_processor_id</span>()] <span style=color:#f92672>=</span> ptr; 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中<code>cpu_cache_get()</code>定义如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span><span style=color:#a6e22e>cpu_cache_get</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cachep<span style=color:#f92672>-&gt;</span>array[<span style=color:#a6e22e>smp_processor_id</span>()];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>smp_processor_id()</code>函数用户获得当前的<code>CPU ID</code>的定义，详细定义暂时不展开。</p><h3 id=5-用kmalloc的空间替换静态分配的slab三链>5） 用<code>kmalloc</code>的空间替换静态分配的slab三链</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 5) Replace the bootstrap kmem_list3&#39;s */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>* 与第4步类似，用kmalloc的空间替换静态分配的slab三链 
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> nid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>for_each_online_node</span>(nid) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* 复制struct kmem_cache的slab三链 */</span>  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>init_list</span>(<span style=color:#f92672>&amp;</span>cache_cache, <span style=color:#f92672>&amp;</span>initkmem_list3[CACHE_CACHE <span style=color:#f92672>+</span> nid], nid);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 复制struct arraycache_init的slab三链 */</span>  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>init_list</span>(malloc_sizes[INDEX_AC].cs_cachep,
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&amp;</span>initkmem_list3[SIZE_AC <span style=color:#f92672>+</span> nid], nid);
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* 复制struct kmem_list3的slab三链 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (INDEX_AC <span style=color:#f92672>!=</span> INDEX_L3) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>init_list</span>(malloc_sizes[INDEX_L3].cs_cachep,
</span></span><span style=display:flex><span>                      <span style=color:#f92672>&amp;</span>initkmem_list3[SIZE_L3 <span style=color:#f92672>+</span> nid], nid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 其中 init_list()函数的定义如下 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * swap the static kmem_list3 with kmalloced memory
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_list</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>list, <span style=color:#66d9ef>int</span> nodeid)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmalloc_node</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> kmem_list3), GFP_KERNEL, nodeid); <span style=color:#75715e>/* 1 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span>ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>memcpy</span>(ptr, list, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> kmem_list3));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Do not assume that spinlocks can be initialized via memcpy:
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock_init</span>(<span style=color:#f92672>&amp;</span>ptr<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>MAKE_ALL_LISTS</span>(cachep, ptr, nodeid); <span style=color:#75715e>/* 2 */</span>
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>nodelists[nodeid] <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 1 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmalloc_node - allocate memory from a specific node
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @size: how many bytes of memory are required.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @flags: the type of memory to allocate (see kcalloc).
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node: node to allocate from.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmalloc() for non-local nodes, used to allocate from a specific node
</span></span></span><span style=display:flex><span><span style=color:#75715e> * if available. Equivalent to kmalloc() in the non-NUMA single-node
</span></span></span><span style=display:flex><span><span style=color:#75715e> * case.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>kmalloc_node</span>(<span style=color:#66d9ef>size_t</span> size, <span style=color:#66d9ef>gfp_t</span> flags, <span style=color:#66d9ef>int</span> node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>kmalloc</span>(size, flags);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 2 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAKE_ALL_LISTS(cachep, ptr, nodeid)                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        do {                                                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        MAKE_LIST((cachep), (&amp;(ptr)-&gt;slabs_full), slabs_full, nodeid);  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        MAKE_LIST((cachep), (&amp;(ptr)-&gt;slabs_partial), slabs_partial, nodeid); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        MAKE_LIST((cachep), (&amp;(ptr)-&gt;slabs_free), slabs_free, nodeid);  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAKE_LIST(cachep, listp, slab, nodeid)                          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        do {                                                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                INIT_LIST_HEAD(listp);                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                list_splice(&amp;(cachep-&gt;nodelists[nodeid]-&gt;slab), listp); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>list_splice <span style=color:#f92672>-</span> join two lists, this is designed <span style=color:#66d9ef>for</span> stacks
</span></span></code></pre></div><h3 id=6-enable_cpucache>6） <code>enable_cpucache</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 6) resize the head arrays to their final sizes */</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>list_for_each_entry</span>(cachep, <span style=color:#f92672>&amp;</span>cache_chain, next)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>enable_cpucache</span>(cachep))
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>BUG</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* enable_cpucache()函数  在分析kmem_cache_create函数的 “初始化本地以及共享的高速缓存”小结分析 */</span>
</span></span></code></pre></div><h3 id=收尾工作>收尾工作</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        <span style=color:#75715e>/* Annotate slab for lockdep -- annotate the malloc caches */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>init_lock_keys</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Done! */</span>
</span></span><span style=display:flex><span>        g_cpucache_up <span style=color:#f92672>=</span> FULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Register a cpu startup notifier callback that initializes
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * cpu_cache_get for all new cpus
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>register_cpu_notifier</span>(<span style=color:#f92672>&amp;</span>cpucache_notifier);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * The reap timers are started later, with a module init call: That part
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * of the kernel is not yet operational.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* init_lock_keys()函数的定义 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_LOCKDEP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Slab sometimes uses the kmalloc slabs to store the slab headers
</span></span></span><span style=display:flex><span><span style=color:#75715e> * for other slabs &#34;off slab&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The locking for this is tricky in that it nests within the locks
</span></span></span><span style=display:flex><span><span style=color:#75715e> * of all other slabs in a few places; to deal with this special
</span></span></span><span style=display:flex><span><span style=color:#75715e> * locking we put on-slab caches into a separate lock-class.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * We set lock class for alien array caches which are up during init.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The lock annotation will be lost if all cpus of a node goes down and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * then comes back up during hotplug
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> lock_class_key on_slab_l3_key;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> lock_class_key on_slab_alc_key;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_lock_keys</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> cache_sizes <span style=color:#f92672>*</span>s <span style=color:#f92672>=</span> malloc_sizes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (s<span style=color:#f92672>-&gt;</span>cs_size <span style=color:#f92672>!=</span> ULONG_MAX) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>for_each_node</span>(q) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>**</span>alc;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> r;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>l3 <span style=color:#f92672>=</span> s<span style=color:#f92672>-&gt;</span>cs_cachep<span style=color:#f92672>-&gt;</span>nodelists[q];
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>l3 <span style=color:#f92672>||</span> <span style=color:#a6e22e>OFF_SLAB</span>(s<span style=color:#f92672>-&gt;</span>cs_cachep))
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>lockdep_set_class</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock, <span style=color:#f92672>&amp;</span>on_slab_l3_key);
</span></span><span style=display:flex><span>                        alc <span style=color:#f92672>=</span> l3<span style=color:#f92672>-&gt;</span>alien;
</span></span><span style=display:flex><span>                        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * FIXME: This check for BAD_ALIEN_MAGIC
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * should go away when common slab code is taught to
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * work even without alien caches.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * Currently, non NUMA code returns BAD_ALIEN_MAGIC
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         * for alloc_alien_cache,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                         */</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>alc <span style=color:#f92672>||</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)alc <span style=color:#f92672>==</span> BAD_ALIEN_MAGIC)
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>for_each_node</span>(r) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (alc[r])
</span></span><span style=display:flex><span>                                        <span style=color:#a6e22e>lockdep_set_class</span>(<span style=color:#f92672>&amp;</span>alc[r]<span style=color:#f92672>-&gt;</span>lock,
</span></span><span style=display:flex><span>                                             <span style=color:#f92672>&amp;</span>on_slab_alc_key);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                s<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_lock_keys</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                                         
</span></span></code></pre></div><h3 id=关于kmem_cache的初始化阶段>关于<code>kmem_cache</code>的初始化阶段</h3><p>由于 SLAB 分配 器的初始化是一个 “鸡和蛋” 的问题，因此 SLAB 分配器将初始化分作几个阶段，通过<code>g_cpucache_up</code> 进行描述，<code>g_cpucache_up</code> 可以取值:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * chicken and egg problem: delay the per-cpu array allocation
</span></span></span><span style=display:flex><span><span style=color:#75715e> * until the general caches are up.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>        NONE,
</span></span><span style=display:flex><span>        PARTIAL_AC,
</span></span><span style=display:flex><span>        PARTIAL_L3,
</span></span><span style=display:flex><span>        FULL
</span></span><span style=display:flex><span>} g_cpucache_up;
</span></span></code></pre></div><ul><li><p><code>NONE</code> 阶段 SLAB 分配器只能分配 <code>struct kmem_cache</code> 对应的高速缓存，且功能不是很完整;</p></li><li><p><code>PARTIAL_AC</code> 阶段 SLAB 分配器已经增加了<code> struct array_cache</code> 对应的高速 缓存，因此高速函数可以为本地高速缓存分配内存了;</p></li><li><p><code>PARTIAL_L3</code> 阶段，SLAB 分配器 增加了<code> struct kmem_list3</code> 的缓存，因此该阶段 <code>kmalloc</code> 等函数已经可以使用;</p></li><li><p><del><code>EARLY</code> 阶段，SLAB 分配器已经将分配器相关的所有数据都使用 SLAB 分配器分配内存，不再使用静态数据</del>;</p></li><li><p><code>FULL</code>阶段 SLAB 分配器已经可以像一个正常的分配器为内核提供接口 进行内存分配和回收.</p><p><del>因此 SLAB 如果处于 EARLY 及其之后都表示 SLAB 已经准备好， 可以开始使用了.</del></p></li></ul><h3 id=总结>总结</h3><p><code>kmem_cache_init()</code>函数主要，</p><ul><li><p>初始化全局链表<code>cache_chain</code></p></li><li><p>创建全局静态变量<code>cache_cache</code> , 将静态创建的变量<code>initarray_cache.array</code>赋值给<code>cache_cache.array</code>;将静态创建的<code>kmem_list3</code>按照内存结点编号赋值给<code>cache_cache.nodelists[nodeid]</code>;</p></li><li><p>创建通用内存分配用的<code>kmem_cache</code> ：<code>size-32</code>等；</p></li><li><p>将初始化<code>cache_cache</code>时用的<code>struct arraycache_init</code>类型的<code>initarray_cache.array</code>以及<code>struct kmem_list3</code>结构放入通用内存（<code>kmalloc</code>分配）的<code>kmem_cache</code>中。</p></li></ul><h3 id=参考资料-1>参考资料</h3><p><a href=http://blog.chinaunix.net/uid-31562863-id-5793196.html>Linux内存管理之slab分配器分析(二 初始化 kmem_cache_init)</a></p><p><a href=https://www.linuxidc.com/Linux/2012-01/51239.htm>Linux内存管理之slab机制（初始化）</a></p><p><a href=https://www.cnblogs.com/openix/p/3351656.html>内存管理 初始化（五）kmem_cache_init 初始化slab分配器(上)</a></p><h2 id=kmem_cache_create>kmem_cache_create</h2><p>SLAB 分配器使用 struct kmem_cache 表示一个高速缓存，其包含了高速缓存的基础信息， 其中也包含了高速缓存的本地缓存、共享缓存，以及 slab 链表等。高速缓存的创建过程 就是用于填充和创建高速缓存所需的数据。</p><p>这函数主要创建一个<code>kmem_cache</code>，但是并不实际分配内存，创建好<code>kmem_cache</code>后调用<code>kmem_cache_alloc()</code>请求分配对象的时候才调用<code>cache_grow()</code>函数向伙伴系统申请内存页框。</p><h3 id=函数参数说明>函数参数说明</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_cache_create - Create a cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @name: A string which is used in /proc/slabinfo to identify this cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @size: The size of objects to be created in this cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @align: The required alignment for the objects.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @flags: SLAB flags
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ctor: A constructor for the objects.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Returns a ptr to the cache on success, NULL on failure.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Cannot be called within a int, but can be interrupted.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The @ctor is run when new pages are allocated by the cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @name must be valid until the cache is destroyed. This implies that
</span></span></span><span style=display:flex><span><span style=color:#75715e> * the module calling this has to destroy the cache before getting unloaded.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Note that kmem_cache_name() is not guaranteed to return the same pointer,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * therefore applications must manage it themselves.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The flags are
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * to catch references to uninitialised memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * %SLAB_RED_ZONE - Insert `Red&#39; zones around the allocated memory to check
</span></span></span><span style=display:flex><span><span style=color:#75715e> * for buffer overruns.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware
</span></span></span><span style=display:flex><span><span style=color:#75715e> * cacheline.  This can be beneficial if you&#39;re counting cycles as closely
</span></span></span><span style=display:flex><span><span style=color:#75715e> * as davem.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><ul><li>name : <code>kmem_cache</code>的名字；</li><li>size: <code>kmem_cache</code>中对象的大小；</li><li>align ：对象所需的对齐方式</li><li>flags : <code>SLAB flags</code><ul><li>SLAB_POISON</li><li>SLAB_RED_ZONE</li><li>SLAB_HWCACHE_ALIGN</li></ul></li><li>ctor : 一个构造函数，当向<code>kmem_cache</code>中添加新的物理页时被调用。</li></ul><h3 id=检查参数以及运行环境>检查参数以及运行环境</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>kmem_cache_create</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>size_t</span> size, <span style=color:#66d9ef>size_t</span> align,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags, <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>ctor)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>size_t</span> left_over, slab_size, ralign;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep <span style=color:#f92672>=</span> NULL, <span style=color:#f92672>*</span>pc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Sanity checks... these are all serious usage bugs.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>name <span style=color:#f92672>||</span> <span style=color:#a6e22e>in_interrupt</span>() <span style=color:#f92672>||</span> (size <span style=color:#f92672>&lt;</span> BYTES_PER_WORD) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            size <span style=color:#f92672>&gt;</span> KMALLOC_MAX_SIZE) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printk</span>(KERN_ERR <span style=color:#e6db74>&#34;%s: Early error in slab %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __func__,
</span></span><span style=display:flex><span>                                name);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>BUG</span>();
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>这一段代码主要判断传入的参数或者CPU运行的环境是否满足。如果1.调用函数时参数中给的name为空; 2. 此时CPU在执行中断服务程序 （in_interrupt()此函数通过thread_info的一下信息去判断，以后分析进程管理的时候再分析; 3. 要创建的kmem_cache的size比一个字的字节数还少或比kmalloc所允许分配的最大的内存还大， 就报oops错。</p><p><code>BYTES_PER_WORD</code>和<code>KMALLOC_MAX_SIZE</code>的定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define BYTES_PER_WORD          sizeof(void *)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The largest kmalloc size supported by the slab allocators is
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 32 megabyte (2^25) or the maximum allocatable page order if that is
</span></span></span><span style=display:flex><span><span style=color:#75715e> * less than 32 MB.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * WARNING: Its not easy to increase this value since the allocators have
</span></span></span><span style=display:flex><span><span style=color:#75715e> * to do various tricks to work around compiler limitations in order to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ensure proper constant folding.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define KMALLOC_SHIFT_HIGH      ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                (MAX_ORDER + PAGE_SHIFT - 1) : 25)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define KMALLOC_MAX_SIZE        (1UL &lt;&lt; KMALLOC_SHIFT_HIGH)
</span></span></span></code></pre></div><p>继续分析<code>kmem_cache_create()</code>函数的流程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * We use cache_chain_mutex to ensure a consistent view of
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * cpu_online_mask as well.  Please see cpuup_callback
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>get_online_cpus</span>(); <span style=color:#75715e>/* 如果此时系统支持CPU热插拔，那么此函数获得可用的CPU，否则什么都不干 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* 遍历所有的高速缓存 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>list_for_each_entry</span>(pc, <span style=color:#f92672>&amp;</span>cache_chain, next) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>char</span> tmp;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> res;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * This happens when the module gets unloaded and doesn&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * destroy its slab cache and no-one else reuses the vmalloc
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * area of the module.  Print a warning.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                res <span style=color:#f92672>=</span> <span style=color:#a6e22e>probe_kernel_address</span>(pc<span style=color:#f92672>-&gt;</span>name, tmp);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (res) {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>printk</span>(KERN_ERR
</span></span><span style=display:flex><span>                               <span style=color:#e6db74>&#34;SLAB: cache with size %d has lost its name</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                               pc<span style=color:#f92672>-&gt;</span>buffer_size);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(pc<span style=color:#f92672>-&gt;</span>name, name)) { <span style=color:#75715e>/* 如果发现已经存在相同名字的高速缓存就dump_stack()并报oops */</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>printk</span>(KERN_ERR
</span></span><span style=display:flex><span>                               <span style=color:#e6db74>&#34;kmem_cache_create: duplicate cache %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, name);
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>dump_stack</span>();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>goto</span> oops;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>WARN_ON</span>(<span style=color:#a6e22e>strchr</span>(name, <span style=color:#e6db74>&#39; &#39;</span>));     <span style=color:#75715e>/* It confuses parsers */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if FORCED_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Enable redzoning and last user accounting, except for caches with
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * large objects, if the increased size would increase the object size
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * above the next power of two: caches with object sizes just above a
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * power of two have a significant amount of internal fragmentation.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4096</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fls</span>(size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#a6e22e>fls</span>(size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> REDZONE_ALIGN <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                                <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)))
</span></span><span style=display:flex><span>                flags <span style=color:#f92672>|=</span> SLAB_RED_ZONE <span style=color:#f92672>|</span> SLAB_STORE_USER;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(flags <span style=color:#f92672>&amp;</span> SLAB_DESTROY_BY_RCU))
</span></span><span style=display:flex><span>                flags <span style=color:#f92672>|=</span> SLAB_POISON;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_DESTROY_BY_RCU)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>BUG_ON</span>(flags <span style=color:#f92672>&amp;</span> SLAB_POISON);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Always checks flags, a caller might be expecting debug support which
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * isn&#39;t available.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>(flags <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>CREATE_MASK);
</span></span></code></pre></div><h3 id=计算对齐>计算对齐</h3><p>根据高速缓存创建时提供的标志进行对齐相关的操作， 最终会将对齐的结果存储在 align 变量里.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Check that size is in terms of words.  This is needed to avoid
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * unaligned accesses for some archs when redzoning is used, and makes
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * sure any on-slab bufctl&#39;s are also correctly aligned.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&amp;</span> (BYTES_PER_WORD <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>                size <span style=color:#f92672>+=</span> (BYTES_PER_WORD <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                size <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(BYTES_PER_WORD <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }     
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* calculate the final buffer alignment: */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 1) arch recommendation: can be overridden for debug */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_HWCACHE_ALIGN) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * Default alignment: as specified by the arch code.  Except if
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * an object is really small, then squeeze multiple objects into
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * one cacheline.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                ralign <span style=color:#f92672>=</span> <span style=color:#a6e22e>cache_line_size</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (size <span style=color:#f92672>&lt;=</span> ralign <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>                        ralign <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                ralign <span style=color:#f92672>=</span> BYTES_PER_WORD;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Redzoning and user store require word alignment or possibly larger.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Note this will be overridden by architecture or caller mandated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * alignment if either is greater than BYTES_PER_WORD.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_STORE_USER)
</span></span><span style=display:flex><span>                ralign <span style=color:#f92672>=</span> BYTES_PER_WORD;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_RED_ZONE) {
</span></span><span style=display:flex><span>                ralign <span style=color:#f92672>=</span> REDZONE_ALIGN;
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* If redzoning, ensure that the second redzone is suitably
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * aligned, by adjusting the object size accordingly. */</span>
</span></span><span style=display:flex><span>                size <span style=color:#f92672>+=</span> REDZONE_ALIGN <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                size <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(REDZONE_ALIGN <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 2) arch mandated alignment */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ralign <span style=color:#f92672>&lt;</span> ARCH_SLAB_MINALIGN) {
</span></span><span style=display:flex><span>                ralign <span style=color:#f92672>=</span> ARCH_SLAB_MINALIGN;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 3) caller mandated alignment */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ralign <span style=color:#f92672>&lt;</span> align) {
</span></span><span style=display:flex><span>                ralign <span style=color:#f92672>=</span> align;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* disable debug if necessary */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ralign <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>__alignof__</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>))
</span></span><span style=display:flex><span>                flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(SLAB_RED_ZONE <span style=color:#f92672>|</span> SLAB_STORE_USER);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 4) Store it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        align <span style=color:#f92672>=</span> ralign;
</span></span></code></pre></div><h3 id=分配kmem_cache描述符>分配<code>kmem_cache</code>描述符</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        <span style=color:#75715e>/* Get cache&#39;s description obj. */</span>
</span></span><span style=display:flex><span>        cachep <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_zalloc</span>(<span style=color:#f92672>&amp;</span>cache_cache, GFP_KERNEL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cachep)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> oops;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cachep<span style=color:#f92672>-&gt;</span>obj_size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Both debugging options require word-alignment which is calculated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * into align above.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_RED_ZONE) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* add space for red zone words */</span>
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>obj_offset <span style=color:#f92672>+=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>);
</span></span><span style=display:flex><span>                size <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_STORE_USER) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* user store requires one word storage behind the end of
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * the real object. But if the second red zone needs to be
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * aligned to 64 bits, we must allow that much space.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> SLAB_RED_ZONE)
</span></span><span style=display:flex><span>                        size <span style=color:#f92672>+=</span> REDZONE_ALIGN;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                        size <span style=color:#f92672>+=</span> BYTES_PER_WORD;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#if FORCED_DEBUG &amp;&amp; defined(CONFIG_DEBUG_PAGEALLOC)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&gt;=</span> malloc_sizes[INDEX_L3 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].cs_size
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> cachep<span style=color:#f92672>-&gt;</span>obj_size <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>cache_line_size</span>() <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>&lt;</span> PAGE_SIZE) {
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>obj_offset <span style=color:#f92672>+=</span> PAGE_SIZE <span style=color:#f92672>-</span> size;
</span></span><span style=display:flex><span>                size <span style=color:#f92672>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><h3 id=判断slab管理数据是放在slab内部还是外部>判断slab管理数据是放在slab内部还是外部</h3><p>判断依据是<code>kmem_cache</code>中对象的大小，即传递给<code>kmem_cache_create()</code>函数的<code>size</code>参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Determine if the slab management is &#39;on&#39; or &#39;off&#39; slab.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * (bootstrapping cannot cope with offslab caches so don&#39;t do
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * it too early on.)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((size <span style=color:#f92672>&gt;=</span> (PAGE_SIZE <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>slab_early_init) 
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * Size is large, assume best to place the slab management obj
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * off-slab (should allow better packing of objs).
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                flags <span style=color:#f92672>|=</span> CFLGS_OFF_SLAB;  
</span></span></code></pre></div><p>这个<code>if</code>判断 slab 默认的管理数据是位于 slab 内部还是外部，判断的条件之一是 <code>slab_early_init</code> 是否为零（<code>kmem_cache_init()</code>函数）在2+3）步骤时赋值为0），这也说明了 SLAB 初始化完毕之前， slab 的管理数据默认只能待在 slab 内部。</p><p>函数判断如果 slab 管理数据位于 slab 外部，必须满足这几个条件: 其一高速缓存对象的长度不小于 “PAGE_SIZE » 3”, 其二 SLAB 分配器已经过了基础初始化阶段， 只有同时满足上面条件，那么 slab 的管理数据才能位于 slab 外部. 如果条件都满足了，那么函数将 CFLAGS_OFF_SLAB 标志添加到 flags 参数 里面. （在后来版本的内核中还加入了第三个条件： flags 标志不能包含 SLAB_NOLEAKTRACE.）</p><h3 id=计算slab的容量>计算slab的容量</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        size <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(size, align); <span style=color:#75715e>/* 获得高速缓存对象对齐之后的长度 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        left_over <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculate_slab_order</span>(cachep, size, align, flags); <span style=color:#75715e>/* 计算出高速缓存每个 slab 维护缓存对象的数量， */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cachep<span style=color:#f92672>-&gt;</span>num) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printk</span>(KERN_ERR
</span></span><span style=display:flex><span>                       <span style=color:#e6db74>&#34;kmem_cache_create: couldn&#39;t create cache %s.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, name);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>kmem_cache_free</span>(<span style=color:#f92672>&amp;</span>cache_cache, cachep);
</span></span><span style=display:flex><span>                cachep <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> oops;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        slab_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(cachep<span style=color:#f92672>-&gt;</span>num <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>kmem_bufctl_t</span>)
</span></span><span style=display:flex><span>                          <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> slab), align); <span style=color:#75715e>/* 计算除了 slab 管理数据的长度，并存储在 slab_size 变量中. */</span>
</span></span></code></pre></div><p>首先，获得高速缓存对象对齐之后的长度，然后，调用 <code>calculate_slab_order()</code> 函数计算出高速缓存每个 slab 维护缓存对象的数量，然后，计算每个 slab 占用物理页的数量，并计算出每个 slab 剩余的内存数量. 函数在 2306 行计算除了 slab 管理数据的长度，并存储在 slab_size 变量中.</p><h3 id=最终确定slab管理数据的存储位置>最终确定slab管理数据的存储位置</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * If the slab has been placed off-slab, and we have enough space then
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * move it on-slab. This is at the expense of any extra colouring.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> CFLGS_OFF_SLAB <span style=color:#f92672>&amp;&amp;</span> left_over <span style=color:#f92672>&gt;=</span> slab_size) {
</span></span><span style=display:flex><span>                flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>CFLGS_OFF_SLAB;
</span></span><span style=display:flex><span>                left_over <span style=color:#f92672>-=</span> slab_size;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> CFLGS_OFF_SLAB) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* really off slab. No need for manual alignment */</span>
</span></span><span style=display:flex><span>                slab_size <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                    cachep<span style=color:#f92672>-&gt;</span>num <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>kmem_bufctl_t</span>) <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> slab);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>检测 slab 的管理数据是否位于 slab 外面，同时也检测 slab 剩余 的内存是否比 slab 管理数据大。</p><p>如果高速缓存的 flags 参数包含了 CFLAGS_OFF_SLAB 标志，即表示想让 slab 管理数据位于 slab 外部，当如果此时 slab 管理数据的长度 小于等于 slab 剩余的内存，那么 SLAB 分配器不会让该高速缓存的 slab 管理数据 位于 slab 外部，因此将 CFLAGS_OFF_SLAB 标志从 flags 中移除，并将 slab 中剩余 的内存减去了 slab 管理数据的长度.</p><p>函数接着检测 slab 管理数据是否位于 slab 外部，如果此时 slab 管理数据 位于 slab 外部，那么 SLAB 分配器需要独立计算 slab 管理数据占用的内存数量，从上图可以看出 slab 管理数据包括了 <code>struct slab</code> 以及 <code>kmem_bufctl</code> 数组，<code>kmem_bufctl</code> 数组的长度与 slab 中位于缓存对象数量有关.</p><h3 id=计算slab着色>计算slab着色</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>colour_off <span style=color:#f92672>=</span> <span style=color:#a6e22e>cache_line_size</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Offset must be a multiple of the alignment. */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>colour_off <span style=color:#f92672>&lt;</span> align)
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>colour_off <span style=color:#f92672>=</span> align;
</span></span><span style=display:flex><span><span style=color:#75715e>/*2337*/</span>cachep<span style=color:#f92672>-&gt;</span>colour <span style=color:#f92672>=</span> left_over <span style=color:#f92672>/</span> cachep<span style=color:#f92672>-&gt;</span>colour_off;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>slab_size <span style=color:#f92672>=</span> slab_size;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>=</span> flags;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>gfpflags <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (CONFIG_ZONE_DMA_FLAG <span style=color:#f92672>&amp;&amp;</span> (flags <span style=color:#f92672>&amp;</span> SLAB_CACHE_DMA))
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>gfpflags <span style=color:#f92672>|=</span> GFP_DMA;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>reciprocal_buffer_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>reciprocal_value</span>(size);
</span></span></code></pre></div><p>调用<code>cache_line_size() </code>计算出当前 <code>cache line</code> 的长度，以此作为高速 缓存着色的长度，存储在高速缓存的 <code>colour_off</code> 成员里，如果 <code>cache line</code> 的长度 小于之前计算出来的对齐长度，那么函数还是将高速缓存的着色长度设置为<code> align</code>。</p><p>函数在 2337 行将之前获得的 slab 剩余的内存除以着色长度，以此获得高速缓存着色范围，并存储在高速缓存的 colour 成员里.</p><p>接着在 2338 行将 slab 管理数据的长度 存储在高速缓存的 slab_size 成员里，</p><p>2339 行将高速缓存的创建标志存在在 flags 成员里，</p><p>并在 2341 行到 2342 行计算高速缓存从 Buddy 分配器中获得物理页的标志.</p><p>2343 行将缓存对象的长度存储在高速缓存的 buffer_size 成员里.</p><h3 id=初始化slab构造函数>初始化slab构造函数</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> CFLGS_OFF_SLAB) {
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>slabp_cache <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_find_general_cachep</span>(slab_size, <span style=color:#ae81ff>0u</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * This is a possibility for one of the malloc_sizes caches.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * But since we go off slab only for object size greater than
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * PAGE_SIZE/8, and malloc_sizes gets created in ascending order,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * this should not happen at all.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * But leave a BUG_ON for some lucky dude.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#a6e22e>ZERO_OR_NULL_PTR</span>(cachep<span style=color:#f92672>-&gt;</span>slabp_cache));
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>ctor <span style=color:#f92672>=</span> ctor; <span style=color:#75715e>/* 设置了高速缓存的构造函数 */</span>
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>name <span style=color:#f92672>=</span> name; <span style=color:#75715e>/* 设置了高速缓存的名字*/</span>
</span></span></code></pre></div><p>检测 slab 管理数据是否位于 slab 外部，如果位于，那么函数调用<code>kmem_find_general_cachep()</code> 函数根据 slab 管理数据的长度，从 SLAB 中获得一个 合适的通用高速缓存，并使用高速缓存的 <code>slabp_cache</code> 指向该通用高速缓存.</p><p>之后函数 设置了高速缓存的构造函数和高速缓存的名字.</p><h3 id=初始化本地以及共享的高速缓存>初始化本地以及共享的高速缓存</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>setup_cpu_cache</span>(cachep)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>__kmem_cache_destroy</span>(cachep);
</span></span><span style=display:flex><span>                cachep <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> oops;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* cache setup completed, link it into the list */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>list_add</span>(<span style=color:#f92672>&amp;</span>cachep<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>&amp;</span>cache_chain);
</span></span></code></pre></div><p>调用<code>setup_cpu_cache()</code> 函数用于设置高速缓存的本地高速缓存、 共享高速缓存以及 slab 链表. 如果设置失败，那么函数调用 <code>__kmem_cache_destroy()</code> 函数摧毁该高速缓存，并将高速缓存指针 cachep 设置为 NULL, 最后跳转到 oops. 如果分配成功，那么将高速缓存插入到系统高速缓存链表 cache_chain 里.</p><h4 id=setup_cpu_cache>setup_cpu_cache()</h4><p>在每个高速缓存中，SLAB 分配器为加速高速缓存的分配速度，为每个 CPU 创建了一个 本地高速缓存，其使用一个缓存栈维护一定数量的可用缓存对象.</p><p>由于 SLAB 分配器的初始化分作多个阶段，每个阶段都涉及到为高速缓存创建本地高速缓存。</p><p>SLAB 分配器 使用 <code>g_cpucache_up</code> 变量来标示 SLAB 分配器的初始化进度。</p><p>SLAB 分配器初始化的第一阶段，这个阶段<code>struct kmem_list3</code> 和<code>struct cache_array</code> 对应的高速缓存还没有创建，因此为该阶段的高速缓存分配本地缓存只能使用静态变量<code>initarray_generic</code>对应的本地高速缓存，由于这个阶段只有 一个 CPU 在运行，因此函数在 首先设置了本地高速缓存.</p><p>然后调用<code>set_up_list3s()</code>函数设置这个阶段的<code>kmem_list3</code> 链表. 如果此时<code>INDEX_AC</code> 的值与<code>INDEX_L3</code>的值 相等，那么函数将 SLAB 初始化进度设置为<code> PARTIAL_L3</code>; 反之设置为<code> PARTIAL_AC</code>。通过 源码分析可以知道，此时<code> INDEX_AC</code> 与<code> INDEX_L3</code>不相等，因此将 SLAB 分配器初始化 进度设置为<code> PARTIAL_AC</code>.</p><p>SLAB 分配器初始化进度达到 第二阶段之后，首先为高速缓存分配本地高速缓存, 此时 <code>kmalloc()</code> 函数已经可以使用，2047 行到 2048 行，函数调用<code>kmalloc()</code>函数为高速缓存分配内存， 此时系统还是只有一个 CPU，由于此时 SLAB 分配器初始化进度是 <code>PARTIAL_AC</code>，因此 函数在 2051 行将 SLAB 分配器初始化进度设置为 <code>PARTIAL_L3</code>;</p><p>当 SLAB 分配器初始化 进入第三阶段，此时系统中多个 CPU 已经可以使用，因此函数在 2055 行遍历所有的 在线 CPU，并调用 <code>kmalloc_node()</code> 函数为每个 CPU 分配本地高速缓存，并调用<code> kmem_list3_init()</code>函数初始化高速缓存的<code>kmem_list3</code>链表. 对于 SLAB 分配器 初始化进度前三个阶段，SLAB 分配器将这些阶段的本地缓存维护的缓存对象控制在 <code>BOOT_CPUCACHE_ENTRIES</code> 个.</p><p>函数 2068 行到 2073 行初始化了基础的成员.</p><p>SLAB 分配器初始化进度到第四阶段，即 g_cpucache_up 等于 FULL, 那么函数在 2026 行 调用 <code>enable_cpucache()</code> 函数初始化高速缓存的本地高速缓存、共享高速缓存，以及<code>kmem_list3 slab</code> 链表.</p><p><code>setup_cpu_cache()</code>函数用于为高速缓存设置本地高速缓存. 参数 cachep 指向高速缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __init_refok <span style=color:#a6e22e>setup_cpu_cache</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (g_cpucache_up <span style=color:#f92672>==</span> FULL)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>enable_cpucache</span>(cachep); <span style=color:#75715e>/* 2026 行 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (g_cpucache_up <span style=color:#f92672>==</span> NONE) {  <span style=color:#75715e>/* slab分配器处于初始化第一阶段 */</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * Note: the first kmem_cache_create must create the cache
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * that&#39;s used by kmalloc(24), otherwise the creation of
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * further caches will BUG().
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                cachep<span style=color:#f92672>-&gt;</span>array[<span style=color:#a6e22e>smp_processor_id</span>()] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>initarray_generic.cache; <span style=color:#75715e>/*设置了本地高速缓存*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * If the cache that&#39;s used by kmalloc(sizeof(kmem_list3)) is
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * the first cache, then we need to set up all its list3s,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * otherwise the creation of further caches will BUG().
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>set_up_list3s</span>(cachep, SIZE_AC); <span style=color:#75715e>/* 设置初始化阶段的kmem_list3链表 */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (INDEX_AC <span style=color:#f92672>==</span> INDEX_L3)
</span></span><span style=display:flex><span>                        g_cpucache_up <span style=color:#f92672>=</span> PARTIAL_L3;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                        g_cpucache_up <span style=color:#f92672>=</span> PARTIAL_AC; 
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>/*第二阶段*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*2047*/</span>        cachep<span style=color:#f92672>-&gt;</span>array[<span style=color:#a6e22e>smp_processor_id</span>()] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>kmalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> arraycache_init), GFP_KERNEL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (g_cpucache_up <span style=color:#f92672>==</span> PARTIAL_AC) {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>set_up_list3s</span>(cachep, SIZE_L3);
</span></span><span style=display:flex><span>                        g_cpucache_up <span style=color:#f92672>=</span> PARTIAL_L3;   <span style=color:#75715e>/*2051 */</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>/*第三阶段*/</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> node;
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>for_each_online_node</span>(node) { 
</span></span><span style=display:flex><span>                                cachep<span style=color:#f92672>-&gt;</span>nodelists[node] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                                    <span style=color:#a6e22e>kmalloc_node</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> kmem_list3),
</span></span><span style=display:flex><span>                                                GFP_KERNEL, node);
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span>cachep<span style=color:#f92672>-&gt;</span>nodelists[node]);
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>kmem_list3_init</span>(cachep<span style=color:#f92672>-&gt;</span>nodelists[node]);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>nodelists[<span style=color:#a6e22e>numa_node_id</span>()]<span style=color:#f92672>-&gt;</span>next_reap <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                        jiffies <span style=color:#f92672>+</span> REAPTIMEOUT_LIST3 <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                        ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)cachep) <span style=color:#f92672>%</span> REAPTIMEOUT_LIST3;
</span></span><span style=display:flex><span>		<span style=color:#75715e>/*初始化了基础的成员*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cpu_cache_get</span>(cachep)<span style=color:#f92672>-&gt;</span>avail <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>/*2068*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cpu_cache_get</span>(cachep)<span style=color:#f92672>-&gt;</span>limit <span style=color:#f92672>=</span> BOOT_CPUCACHE_ENTRIES;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cpu_cache_get</span>(cachep)<span style=color:#f92672>-&gt;</span>batchcount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cpu_cache_get</span>(cachep)<span style=color:#f92672>-&gt;</span>touched <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>batchcount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>limit <span style=color:#f92672>=</span> BOOT_CPUCACHE_ENTRIES;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=enable_cpucache>enable_cpucache()</h4><p><code>enable_cpucache()</code> 函数用于计算一个高速缓存的本地缓存维护缓存对象的数量，以及高速缓存对应的共享高速缓存维护缓存对象的数量，并为高速缓存分配本地缓存和 <code>kmem_list3</code> 链表, 最后更新本地缓存.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Called with cache_chain_mutex held always */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>enable_cpucache</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> err;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> limit, shared;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * The head array serves three purposes:
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * - create a LIFO ordering, i.e. return objects that are cache-warm
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * - reduce the number of spinlock operations.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * - reduce the number of linked list operations on the slab and
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *   bufctl chains: array operations are cheaper.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * The numbers are guessed, we should auto-tune as described by
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Bonwick.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>131072</span>) <span style=color:#75715e>/* 3971  */</span>
</span></span><span style=display:flex><span>                limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>&gt;</span> PAGE_SIZE)
</span></span><span style=display:flex><span>                limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span>                limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>256</span>)
</span></span><span style=display:flex><span>                limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>54</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>; <span style=color:#75715e>/* 3980 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * CPU bound tasks (e.g. network routing) can exhibit cpu bound
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * allocation behaviour: Most allocs on one cpu, most free operations
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * on another cpu. For these cases, an efficient object passing between
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * cpus is necessary. This is provided by a shared array. The array
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * replaces Bonwick&#39;s magazine layer.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * On uniprocessor, it&#39;s functionally equivalent (but less efficient)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * to a larger limit. Thus disabled by default.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        shared <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>/* 3991 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>&lt;=</span> PAGE_SIZE <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>num_possible_cpus</span>() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                shared <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * With debugging enabled, large batchcount lead to excessively long
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * periods with disabled local interrupts. Limit the batchcount
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (limit <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>                limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        err <span style=color:#f92672>=</span> <span style=color:#a6e22e>do_tune_cpucache</span>(cachep, limit, (limit <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, shared); <span style=color:#75715e>/* 4003  */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (err)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printk</span>(KERN_ERR <span style=color:#e6db74>&#34;enable_cpucache failed for %s, error %d.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                       cachep<span style=color:#f92672>-&gt;</span>name, <span style=color:#f92672>-</span>err);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> err;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SLAB 分配器为加快高速缓存的分配速度，为每个 CPU 创建了一个本地高速缓存，其使用 一个缓存栈维护一定数量的可用缓存对象，每个 CPU 都可以快速从缓存栈上分配可用 的缓存对象.</p><p>SLAB 分配器还为高速缓存创建了一个共享高速缓存，所有 CPU 都可以从共享高速缓存中获得可用的缓存对象。</p><p>SLAB 分配器使用<code> kmem_list3</code> 链表为高速缓存在指定 NODE 上维护了 3 类链表，以此管理指定的 slab。</p><p><code>enable_cpucache()</code> 函数就是用于为一个高速缓存规划本地高速缓存和共享高速缓存中维护缓存对象的数量，以及创建并更新本地缓存，最后为高速缓存创建 <code>kmem_list3 </code>链表。</p><p>函数 3971 行到 3980 行用于计算一个高速缓存对应的本地高速缓存维护可用缓存对象的数量，从代码逻辑可以推断高速缓存对象越大，本地高速缓存能够维护可用缓存对象 数量越少。</p><p>3991 行到 3993 行，如果高速缓存对象的大小不大于<code> PAGE_SIZE</code>, 且 <code>num_possible_cpus()</code> 数量大于 1，即 CPU 数量大于 1，那么将共享高速缓存维护的缓存对象设置为 8.</p><p>最后函数在 4003 行处调用 <code>do_tune_cpucache() </code>函数为高速缓存 创建了本地高速缓存和共享高速缓存，以及<code> kmem_list3</code> 链表.</p><h4 id=do_tune_cpucache>do_tune_cpucache()</h4><p><code>do_tune_cpucache() </code>函数用于为缓存分配本地缓存、共享缓存和 l3 链表.</p><p>参数 <code>cachep</code> 指向缓存，<code>limit</code> 用于指明本地缓存最大缓存对象的数量。</p><p><code>shared</code> 参数用于 指明共享缓存中缓存对象的数量;</p><p>函数 3920 行调用 <code>kzalloc() </code>函数为 <code>struct ccupdate_struct </code>分配新的内存。</p><p>3924 行到 3933 行，函数调用 <code>for_each_online_cpu()</code> 函数遍历所有的 CPU，并基于 <code>struct ccupdate_struct</code> 结构为 CPU 分配本地缓存结构 <code>struct cache_array</code>, 通过 <code>alloc_arraycache()</code>函数进行分配.</p><p>函数 3936 行调用 <code>on_each_cpu()</code> 函数与<code> do_ccupdate_local()</code> 函数更新当前高速缓存的本地缓存.</p><p>接着函数设置了高速缓存的 <code>batchcount</code>,<code> limit</code> 以及 <code>shared</code> 成员.</p><p>函数 3943 行到 3951 行遍历所有在线的 CPU，如果发生了 CPU 热插拔事件之后，离线的 CPU 没有释放本地缓存，那么函数并检测高速缓存对应的本地缓存是否存在，如果存在，那么释放本地缓存. 函数最后释放 new 变量，并调用 <code>alloc_kmemlist() </code>函数为高速缓存分配<code>kmem_list3</code>链表数据.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>do_tune_cpucache</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>int</span> limit,
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>int</span> batchcount, <span style=color:#66d9ef>int</span> shared)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> ccupdate_struct <span style=color:#f92672>*</span>new;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        new <span style=color:#f92672>=</span> <span style=color:#a6e22e>kzalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>new), GFP_KERNEL); <span style=color:#75715e>/* 3920  */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>new)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>for_each_online_cpu</span>(i) { <span style=color:#75715e>/* 3924 */</span>
</span></span><span style=display:flex><span>                new<span style=color:#f92672>-&gt;</span>new[i] <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_arraycache</span>(<span style=color:#a6e22e>cpu_to_node</span>(i), limit,
</span></span><span style=display:flex><span>                                                batchcount);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>new<span style=color:#f92672>-&gt;</span>new[i]) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (i<span style=color:#f92672>--</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>kfree</span>(new<span style=color:#f92672>-&gt;</span>new[i]);
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>kfree</span>(new);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        } <span style=color:#75715e>/* 3933 */</span>
</span></span><span style=display:flex><span>        new<span style=color:#f92672>-&gt;</span>cachep <span style=color:#f92672>=</span> cachep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>on_each_cpu</span>(do_ccupdate_local, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)new, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>/* 3936 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_on</span>();
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>batchcount <span style=color:#f92672>=</span> batchcount;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>limit <span style=color:#f92672>=</span> limit;
</span></span><span style=display:flex><span>        cachep<span style=color:#f92672>-&gt;</span>shared <span style=color:#f92672>=</span> shared;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>for_each_online_cpu</span>(i) { <span style=color:#75715e>/* 3943  */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span>ccold <span style=color:#f92672>=</span> new<span style=color:#f92672>-&gt;</span>new[i];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ccold)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>spin_lock_irq</span>(<span style=color:#f92672>&amp;</span>cachep<span style=color:#f92672>-&gt;</span>nodelists[<span style=color:#a6e22e>cpu_to_node</span>(i)]<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>free_block</span>(cachep, ccold<span style=color:#f92672>-&gt;</span>entry, ccold<span style=color:#f92672>-&gt;</span>avail, <span style=color:#a6e22e>cpu_to_node</span>(i));
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>spin_unlock_irq</span>(<span style=color:#f92672>&amp;</span>cachep<span style=color:#f92672>-&gt;</span>nodelists[<span style=color:#a6e22e>cpu_to_node</span>(i)]<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>kfree</span>(ccold);
</span></span><span style=display:flex><span>        } <span style=color:#75715e>/* 3951  */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kfree</span>(new);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>alloc_kmemlist</span>(cachep);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>alloc_arraycache()</p><p>alloc_kmemlist()</p><p>struct ccupdate_struct</p><h3 id=oops的处理流程>oops的处理流程</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>oops:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cachep <span style=color:#f92672>&amp;&amp;</span> (flags <span style=color:#f92672>&amp;</span> SLAB_PANIC))
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;kmem_cache_create(): failed to create slab `%s&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                      name);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>put_online_cpus</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cachep;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(kmem_cache_create);
</span></span><span style=display:flex><span>                                                           
</span></span></code></pre></div><p><code>oops</code>的处理流程：首先判断高速缓存是否已经成功分配了，如果没有成功分配且<code>flags</code> 中包含了<code>SLAB_PANIC</code>标志，那么调用<code> panic()</code> 函数. 否则，函数解除 <code>cache_chain_mutex</code> 互斥锁，并调用 <code>put_online_cpus()</code> 函数。函数最后返回指向高速缓存的指针 <code>cachep</code>，并将该函数通过 <code>EXPORT_SYMBOL()</code> 导出给内核其他部分使用.</p><h2 id=kmem_cache_alloc>kmem_cache_alloc</h2><p><code>kmem_cache_alloc()</code>函数用于从缓存对象中分配一个可用的缓存对象. 参数 <code>cachep</code> 指向缓存对象; 参数<code>flags</code>用于指明分配物理内存标志。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_cache_alloc - Allocate an object
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @cachep: The cache to allocate from.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @flags: See kmalloc().
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Allocate an object from this cache.  The flags are only relevant
</span></span></span><span style=display:flex><span><span style=color:#75715e> * if the cache has no available objects.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>kmem_cache_alloc</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>gfp_t</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>__cache_alloc</span>(cachep, flags, <span style=color:#a6e22e>__builtin_return_address</span>(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>trace_kmem_cache_alloc</span>(_RET_IP_, ret,
</span></span><span style=display:flex><span>                               <span style=color:#a6e22e>obj_size</span>(cachep), cachep<span style=color:#f92672>-&gt;</span>buffer_size, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(kmem_cache_alloc);
</span></span></code></pre></div><p>__cache_alloc()定义如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>__cache_alloc</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>gfp_t</span> flags, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>caller)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> save_flags;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lockdep_trace_alloc</span>(flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>slab_should_failslab</span>(cachep, flags))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cache_alloc_debugcheck_before</span>(cachep, flags);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>local_irq_save</span>(save_flags);
</span></span><span style=display:flex><span>        objp <span style=color:#f92672>=</span> <span style=color:#a6e22e>__do_cache_alloc</span>(cachep, flags); <span style=color:#75715e>/* 分配可用的缓存对象 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>local_irq_restore</span>(save_flags);
</span></span><span style=display:flex><span>        objp <span style=color:#f92672>=</span> <span style=color:#a6e22e>cache_alloc_debugcheck_after</span>(cachep, flags, objp, caller);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>prefetchw</span>(objp); <span style=color:#75715e>/* 将可用缓存对象预加载到 CACHE */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>((flags <span style=color:#f92672>&amp;</span> __GFP_ZERO) <span style=color:#f92672>&amp;&amp;</span> objp)) <span style=color:#75715e>/* 如果检测到 flags 参数中包含了 __GFP_ZERO 标志， */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>memset</span>(objp, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>obj_size</span>(cachep)); <span style=color:#75715e>/* 调用 memset() 函数将缓存对象指向的内存清零. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> objp; <span style=color:#75715e>/*  最后返回缓存对象. */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>__cache_alloc() 函数用于从缓存对象中分配可用的缓存对象. 参数 cachep 指向 缓存对象; 参数 flags 指向物理内存分配标志; 参数 caller 用于指向申请者.</p><p>UMA平台</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>__do_cache_alloc</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>gfp_t</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>____cache_alloc</span>(cachep, flags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>____cache_alloc()函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>____cache_alloc</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>gfp_t</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span>ac;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_off</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ac <span style=color:#f92672>=</span> <span style=color:#a6e22e>cpu_cache_get</span>(cachep); <span style=color:#75715e>/* 获得缓存对应的缓存栈 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(ac<span style=color:#f92672>-&gt;</span>avail)) { <span style=color:#75715e>/* 检测缓存栈的栈顶, 以此判断缓存栈里是否有可用的缓存对象，如果栈顶不为零，即 avail 成员不为 0 */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>STATS_INC_ALLOCHIT</span>(cachep);
</span></span><span style=display:flex><span>                ac<span style=color:#f92672>-&gt;</span>touched <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                objp <span style=color:#f92672>=</span> ac<span style=color:#f92672>-&gt;</span>entry[<span style=color:#f92672>--</span>ac<span style=color:#f92672>-&gt;</span>avail]; <span style=color:#75715e>/* 从缓存栈上获得可用的缓存对象, 并更新缓存栈的栈顶*/</span> 
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>/* 如果栈顶为 0，那么表示缓存栈上没有可用的缓存对象 */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>STATS_INC_ALLOCMISS</span>(cachep);
</span></span><span style=display:flex><span>                objp <span style=color:#f92672>=</span> <span style=color:#a6e22e>cache_alloc_refill</span>(cachep, flags); <span style=color:#75715e>/*调用 cache_alloc_refill() 函数将一定数量的可用缓存对象添加到缓存栈上，并再次使用 ac 变量指向缓存栈. */</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> objp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img alt=array_cache src=https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/TB000001.png></p><p>在 SLAB 分配器里，为了加速缓存对象的分配，SLAB 分配器为缓存对象针对每个 CPU 构建了一个缓存栈，CPU 可以快速从缓存栈上获得可用的缓存对象。其实现原理如上图， 缓存对象使用 struct kmem_cache 进行维护，其成员 array 是一个 <code>struct cache_array</code> 数组，数组中的每个成员对应一个缓存栈，因此 <code>struct cache_array</code> 维护着一个缓存栈.</p><h4 id=cpu_cache_get>cpu_cache_get()</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span><span style=color:#a6e22e>cpu_cache_get</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cachep<span style=color:#f92672>-&gt;</span>array[<span style=color:#a6e22e>smp_processor_id</span>()];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=cache_alloc_refill>cache_alloc_refill()</h4><p>每当 SLAB 分配缓存对象的时候，如果发现缓存栈上没有可用的缓存对象时候，</p><p>那么 SLAB 分配器就会检测缓存对象的 slabs_partial 上是否有可用的 slab，</p><p>​ 如果有，那么 SLAB 从 slabs_partial 的 slab 上获取 batchcount 数量的缓存对象到缓存栈里;</p><p>​ 如果 slabs_partial 上没有可用的 slab，那么 SLAB 分配器检测 slabs_free 上时候有可用 的 slab，</p><p>​ 如果有，那么就从对应的 slab 上获得 batchcount 数量的缓存对象到缓存栈 上;</p><p>​ 如果此时 slabs_free 上也找不到 slab，</p><p>​ 那么 SLAB 分配器需要为缓存对象扩充新 的 slab，那么 SLAB 分配器从 Buddy 分配指定数量的物理内存，并将这些内存组织成 新的 slab，并插入到 slabs_free 链表上，并重新执行之前的查找过程.</p><p>重新查找的过程中，slabs_free 链表上有可用的 slab，那么缓存栈获得 batchcount 数量的缓存对象 之后，将 slab 从 slabs_free 上移除并插入到 slabs_partial 链表上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>cache_alloc_refill</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>gfp_t</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> batchcount;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>l3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> array_cache <span style=color:#f92672>*</span>ac;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>retry:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_off</span>();
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> <span style=color:#a6e22e>numa_node_id</span>();
</span></span><span style=display:flex><span>        ac <span style=color:#f92672>=</span> <span style=color:#a6e22e>cpu_cache_get</span>(cachep); <span style=color:#75715e>/* 获得缓存对象对应的缓存栈，通过 ac 进行指定 */</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>		batchcount <span style=color:#f92672>=</span> ac<span style=color:#f92672>-&gt;</span>batchcount;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ac<span style=color:#f92672>-&gt;</span>touched <span style=color:#f92672>&amp;&amp;</span> batchcount <span style=color:#f92672>&gt;</span> BATCHREFILL_LIMIT) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * If there was little recent activity on this cache, then
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * perform only a partial refill.  Otherwise we could generate
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * refill bouncing.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                batchcount <span style=color:#f92672>=</span> BATCHREFILL_LIMIT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        l3 <span style=color:#f92672>=</span> cachep<span style=color:#f92672>-&gt;</span>nodelists[node]; <span style=color:#75715e>/* 获得缓存对象的 kmem_list3 链表，通过l3进行指定 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>(ac<span style=color:#f92672>-&gt;</span>avail <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>l3);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* See if we can refill from the shared array */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l3<span style=color:#f92672>-&gt;</span>shared <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>transfer_objects</span>(ac, l3<span style=color:#f92672>-&gt;</span>shared, batchcount))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> alloc_done;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (batchcount <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {  <span style=color:#75715e>/* 检测缓存栈的 batchount 是否大于 0，以此确认缓存栈是否在使用，如果小于 1，那么缓存栈不再使用*/</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>entry;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> slab <span style=color:#f92672>*</span>slabp;
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Get slab alloc is to come from. */</span>
</span></span><span style=display:flex><span>                entry <span style=color:#f92672>=</span> l3<span style=color:#f92672>-&gt;</span>slabs_partial.next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>slabs_partial) {
</span></span><span style=display:flex><span>                        l3<span style=color:#f92672>-&gt;</span>free_touched <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                        entry <span style=color:#f92672>=</span> l3<span style=color:#f92672>-&gt;</span>slabs_free.next;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>slabs_free) <span style=color:#75715e>/* 如果最终slabs_free上都没有找到可用的 slab */</span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>goto</span> must_grow; <span style=color:#75715e>/*那么函数跳转到 must_grow分配新的 slab*/</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>				<span style=color:#75715e>/* 找到从 slabs_partial/slabs_free 里找到一个可用的 slab */</span>
</span></span><span style=display:flex><span>                slabp <span style=color:#f92672>=</span> <span style=color:#a6e22e>list_entry</span>(entry, <span style=color:#66d9ef>struct</span> slab, list);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>check_slabp</span>(cachep, slabp);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>check_spinlock_acquired</span>(cachep);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * The slab was either on partial or free list so
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * there must be at least one object available for
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * allocation.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>BUG_ON</span>(slabp<span style=color:#f92672>-&gt;</span>inuse <span style=color:#f92672>&gt;=</span> cachep<span style=color:#f92672>-&gt;</span>num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>					 while 循环，只要确认缓存对象正在使用的缓存对象数量小于缓存对象总数，并且 batchcount 不为0，
</span></span></span><span style=display:flex><span><span style=color:#75715e>					 那么进入循环，在循环中，函数不断从 slab 中将可用缓存对象加入到缓存栈里，并更新缓存栈的栈顶
</span></span></span><span style=display:flex><span><span style=color:#75715e>				*/</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (slabp<span style=color:#f92672>-&gt;</span>inuse <span style=color:#f92672>&lt;</span> cachep<span style=color:#f92672>-&gt;</span>num <span style=color:#f92672>&amp;&amp;</span> batchcount<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>STATS_INC_ALLOCED</span>(cachep);
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>STATS_INC_ACTIVE</span>(cachep);
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>STATS_SET_HIGH</span>(cachep);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        ac<span style=color:#f92672>-&gt;</span>entry[ac<span style=color:#f92672>-&gt;</span>avail<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>slab_get_obj</span>(cachep, slabp,
</span></span><span style=display:flex><span>                                                            node);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>check_slabp</span>(cachep, slabp);
</span></span><span style=display:flex><span>				<span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>					将 slab 从原先的链表中移除，
</span></span></span><span style=display:flex><span><span style=color:#75715e>					如果此时slab 中没有可用的缓存对象，那么将 slab 插到slabs_full 链表中，
</span></span></span><span style=display:flex><span><span style=color:#75715e>					如果此时 slab 中还有部分可用缓存对象，那么将 slab 插入到 slabs_partial 链表中. 
</span></span></span><span style=display:flex><span><span style=color:#75715e>				*/</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* move slabp to correct slabp list: */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>list_del</span>(<span style=color:#f92672>&amp;</span>slabp<span style=color:#f92672>-&gt;</span>list);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (slabp<span style=color:#f92672>-&gt;</span>free <span style=color:#f92672>==</span> BUFCTL_END)
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>list_add</span>(<span style=color:#f92672>&amp;</span>slabp<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>slabs_full);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>list_add</span>(<span style=color:#f92672>&amp;</span>slabp<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>slabs_partial);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>must_grow:
</span></span><span style=display:flex><span>        l3<span style=color:#f92672>-&gt;</span>free_objects <span style=color:#f92672>-=</span> ac<span style=color:#f92672>-&gt;</span>avail;
</span></span><span style=display:flex><span>alloc_done:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#f92672>!</span>ac<span style=color:#f92672>-&gt;</span>avail)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>                x <span style=color:#f92672>=</span> <span style=color:#a6e22e>cache_grow</span>(cachep, flags <span style=color:#f92672>|</span> GFP_THISNODE, node, NULL); <span style=color:#75715e>/* 调用 cache_grow() 函数进行分配 新的 slab */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* cache_grow can reenable interrupts, then ac could change. */</span>
</span></span><span style=display:flex><span>                ac <span style=color:#f92672>=</span> <span style=color:#a6e22e>cpu_cache_get</span>(cachep);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>x <span style=color:#f92672>&amp;&amp;</span> ac<span style=color:#f92672>-&gt;</span>avail <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)       <span style=color:#75715e>/* no objects in sight? abort */</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>				<span style=color:#75715e>/* 函数再次检测缓存栈是否等于 0，如果为真，那么函数重新从缓存栈上分配新的可用缓存栈 */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ac<span style=color:#f92672>-&gt;</span>avail)         <span style=color:#75715e>/* objects refilled by interrupt? */</span> 
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>goto</span> retry;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ac<span style=color:#f92672>-&gt;</span>touched <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/*当缓存栈被访问，那么缓存栈 的 touch 标记为 1*/</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ac<span style=color:#f92672>-&gt;</span>entry[<span style=color:#f92672>--</span>ac<span style=color:#f92672>-&gt;</span>avail]; <span style=color:#75715e>/* 从缓存栈中返回一个可用缓存对象.*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=cache_grow>cache_grow()</h4><p>cache_grow() 函数用于扩充缓存对象的 slab。cachep 参数指向缓存对象; flags 参数 用于从 Buddy 分配器中分配内存的标志; nodeid 参数用于指明 NODE 信息; objp 用于 指向 slab.</p><p>SLAB 分配器在为缓存对象分配新的 slab 时，首先从 Buddy 分配器中分配指定数量的 物理页，然后将这些物理内存进行组织，将其转换成 slab，转换之后在将 slab 对应的 物理页与缓存对象和 slab 进行绑定，最后初始化 slab 的 kmem_bufctl 数组。新的 slab 创建完毕之后，将其插入缓存对象的 slabs_free 链表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Grow (by 1) the number of slabs within a cache.  This is called by
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_cache_alloc() when there are no active objs left in a cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cache_grow</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>gfp_t</span> flags, <span style=color:#66d9ef>int</span> nodeid, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> slab <span style=color:#f92672>*</span>slabp;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>size_t</span> offset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>gfp_t</span> local_flags;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>l3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Be lazy and only check for valid flags here,  keeping it out of the
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * critical path in kmem_cache_alloc().
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>    	<span style=color:#75715e>/* 对分配物理内存的标志进行检查，以此确认分配的物理页是否可以回收或者不可以回收 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>(flags <span style=color:#f92672>&amp;</span> GFP_SLAB_BUG_MASK);
</span></span><span style=display:flex><span>        local_flags <span style=color:#f92672>=</span> flags <span style=color:#f92672>&amp;</span> (GFP_CONSTRAINT_MASK<span style=color:#f92672>|</span>GFP_RECLAIM_MASK); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Take the l3 list lock to change the colour_next on this node */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_off</span>();
</span></span><span style=display:flex><span>        l3 <span style=color:#f92672>=</span> cachep<span style=color:#f92672>-&gt;</span>nodelists[nodeid];     <span style=color:#75715e>/* 获得缓存对象在指定 NODE 的 kmem_list3 数据结构*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Get colour for the slab, and cal the next value. */</span>
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>=</span> l3<span style=color:#f92672>-&gt;</span>colour_next; <span style=color:#75715e>/* 获得了当前着色信息 */</span>
</span></span><span style=display:flex><span>        l3<span style=color:#f92672>-&gt;</span>colour_next<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 更新缓存对象的下一个着色信息 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l3<span style=color:#f92672>-&gt;</span>colour_next <span style=color:#f92672>&gt;=</span> cachep<span style=color:#f92672>-&gt;</span>colour)
</span></span><span style=display:flex><span>                l3<span style=color:#f92672>-&gt;</span>colour_next <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;   <span style=color:#75715e>/* 如果下一个着色信息超过了缓存支持的着色范围，那么将下一个着色信息设置为 0 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>*=</span> cachep<span style=color:#f92672>-&gt;</span>colour_off; <span style=color:#75715e>/* 计算着色预留的内存长度 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (local_flags <span style=color:#f92672>&amp;</span> __GFP_WAIT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * The test for missing atomic flag is performed here, rather than
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * the more obvious place, simply to reduce the critical path length
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * in kmem_cache_alloc(). If a caller is seriously mis-behaving they
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * will eventually be caught here (where it matters).
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem_flagcheck</span>(cachep, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Get mem for the objs.  Attempt to allocate a physical page from
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * &#39;nodeid&#39;.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>objp)
</span></span><span style=display:flex><span>                objp <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_getpages</span>(cachep, local_flags, nodeid); <span style=color:#75715e>/* 从 Buddy 分配器中分配指定数量的物理内存，并获得物理内存对应的虚拟地址，存储中objp 变量里 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>objp)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> failed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Get slab management. */</span>
</span></span><span style=display:flex><span>    	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    		把新分配的内存组织成一个 slab,
</span></span></span><span style=display:flex><span><span style=color:#75715e>    		无论 slab 采用 外部管理数据还是内部管理数据，函数都返回了 slab 管理数据对应的 struct slab 指针
</span></span></span><span style=display:flex><span><span style=color:#75715e>    	*/</span>
</span></span><span style=display:flex><span>        slabp <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_slabmgmt</span>(cachep, objp, offset,
</span></span><span style=display:flex><span>                        local_flags <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>GFP_CONSTRAINT_MASK, nodeid); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>slabp)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> opps1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>slab_map_pages</span>(cachep, slabp, objp); <span style=color:#75715e>/* 将从 Buddy 分配器分配的物理页 与缓存对象和 slab 进行绑定 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cache_init_objs</span>(cachep, slabp); <span style=color:#75715e>/* 初始化 slab 的 kmem_bufctl 数组 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (local_flags <span style=color:#f92672>&amp;</span> __GFP_WAIT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_off</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Make slab active. */</span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	    	将 slab 加入到缓存对象的 slabs_free 链表里，
</span></span></span><span style=display:flex><span><span style=color:#75715e>	    	并添加缓存对象的 kmem_list3 的 free_objects 可用对象数量.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	    */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>list_add_tail</span>(<span style=color:#f92672>&amp;</span>slabp<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>(l3<span style=color:#f92672>-&gt;</span>slabs_free));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>STATS_INC_GROWN</span>(cachep);
</span></span><span style=display:flex><span>        l3<span style=color:#f92672>-&gt;</span>free_objects <span style=color:#f92672>+=</span> cachep<span style=color:#f92672>-&gt;</span>num;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>opps1:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem_freepages</span>(cachep, objp);
</span></span><span style=display:flex><span>failed:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (local_flags <span style=color:#f92672>&amp;</span> __GFP_WAIT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=kmem_getpages>kmem_getpages()</h5><p>从 Buddy 分配器中分配指定数量的物理内存，并获得物理内存对应的虚拟地址，存储中objp 变量里。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Interface to system&#39;s page allocator. No need to hold the cache-lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If we requested dmaable memory, we will get it. Even if we
</span></span></span><span style=display:flex><span><span style=color:#75715e> * did not request dmaable memory, we might get it, but that
</span></span></span><span style=display:flex><span><span style=color:#75715e> * would be relatively rare and ignorable.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>kmem_getpages</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>gfp_t</span> flags, <span style=color:#66d9ef>int</span> nodeid)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> nr_pages;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef CONFIG_MMU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Nommu uses slab&#39;s for process anonymous memory allocations, and thus
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * requires __GFP_COMP to properly refcount higher order allocations
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        flags <span style=color:#f92672>|=</span> __GFP_COMP;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        flags <span style=color:#f92672>|=</span> cachep<span style=color:#f92672>-&gt;</span>gfpflags;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_RECLAIM_ACCOUNT)
</span></span><span style=display:flex><span>                flags <span style=color:#f92672>|=</span> __GFP_RECLAIMABLE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        page <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_pages_node</span>(nodeid, flags, cachep<span style=color:#f92672>-&gt;</span>gfporder);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>page)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        nr_pages <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> cachep<span style=color:#f92672>-&gt;</span>gfporder);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_RECLAIM_ACCOUNT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>add_zone_page_state</span>(<span style=color:#a6e22e>page_zone</span>(page),
</span></span><span style=display:flex><span>                        NR_SLAB_RECLAIMABLE, nr_pages);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>add_zone_page_state</span>(<span style=color:#a6e22e>page_zone</span>(page),
</span></span><span style=display:flex><span>                        NR_SLAB_UNRECLAIMABLE, nr_pages);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> nr_pages; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>__SetPageSlab</span>(page <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>page_address</span>(page);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=alloc_slabmgmt>alloc_slabmgmt()</h5><p>把新分配的内存组织成一个 slab, 无论 slab 采用 外部管理数据还是内部管理数据，函数都返回了 slab 管理数据对应的 struct slab 指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Get the memory for a slab management obj.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * For a slab cache when the slab descriptor is off-slab, slab descriptors
</span></span></span><span style=display:flex><span><span style=color:#75715e> * always come from malloc_sizes caches.  The slab descriptor cannot
</span></span></span><span style=display:flex><span><span style=color:#75715e> * come from the same cache which is getting created because,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * when we are searching for an appropriate cache for these
</span></span></span><span style=display:flex><span><span style=color:#75715e> * descriptors in kmem_cache_create, we search through the malloc_sizes array.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If we are creating a malloc_sizes cache here it would not be visible to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_find_general_cachep till the initialization is complete.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Hence we cannot have slabp_cache same as the original cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> slab <span style=color:#f92672>*</span><span style=color:#a6e22e>alloc_slabmgmt</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp,
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>int</span> colour_off, <span style=color:#66d9ef>gfp_t</span> local_flags,
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>int</span> nodeid)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> slab <span style=color:#f92672>*</span>slabp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>OFF_SLAB</span>(cachep)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Slab management obj is off-slab. */</span>
</span></span><span style=display:flex><span>                slabp <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_cache_alloc_node</span>(cachep<span style=color:#f92672>-&gt;</span>slabp_cache,
</span></span><span style=display:flex><span>                                              local_flags, nodeid);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>slabp)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                slabp <span style=color:#f92672>=</span> objp <span style=color:#f92672>+</span> colour_off;
</span></span><span style=display:flex><span>                colour_off <span style=color:#f92672>+=</span> cachep<span style=color:#f92672>-&gt;</span>slab_size;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        slabp<span style=color:#f92672>-&gt;</span>inuse <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        slabp<span style=color:#f92672>-&gt;</span>colouroff <span style=color:#f92672>=</span> colour_off;
</span></span><span style=display:flex><span>        slabp<span style=color:#f92672>-&gt;</span>s_mem <span style=color:#f92672>=</span> objp <span style=color:#f92672>+</span> colour_off;
</span></span><span style=display:flex><span>        slabp<span style=color:#f92672>-&gt;</span>nodeid <span style=color:#f92672>=</span> nodeid;
</span></span><span style=display:flex><span>        slabp<span style=color:#f92672>-&gt;</span>free <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> slabp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=slab_map_pages>slab_map_pages()</h5><p>将从 Buddy 分配器分配的物理页 与缓存对象和 slab 进行绑定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Grow (by 1) the number of slabs within a cache.  This is called by
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_cache_alloc() when there are no active objs left in a cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cache_grow</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>gfp_t</span> flags, <span style=color:#66d9ef>int</span> nodeid, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> slab <span style=color:#f92672>*</span>slabp;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>size_t</span> offset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>gfp_t</span> local_flags;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> kmem_list3 <span style=color:#f92672>*</span>l3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Be lazy and only check for valid flags here,  keeping it out of the
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * critical path in kmem_cache_alloc().
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>(flags <span style=color:#f92672>&amp;</span> GFP_SLAB_BUG_MASK);
</span></span><span style=display:flex><span>        local_flags <span style=color:#f92672>=</span> flags <span style=color:#f92672>&amp;</span> (GFP_CONSTRAINT_MASK<span style=color:#f92672>|</span>GFP_RECLAIM_MASK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Take the l3 list lock to change the colour_next on this node */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_off</span>();
</span></span><span style=display:flex><span>        l3 <span style=color:#f92672>=</span> cachep<span style=color:#f92672>-&gt;</span>nodelists[nodeid];
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Get colour for the slab, and cal the next value. */</span>
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>=</span> l3<span style=color:#f92672>-&gt;</span>colour_next;
</span></span><span style=display:flex><span>        l3<span style=color:#f92672>-&gt;</span>colour_next<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l3<span style=color:#f92672>-&gt;</span>colour_next <span style=color:#f92672>&gt;=</span> cachep<span style=color:#f92672>-&gt;</span>colour)
</span></span><span style=display:flex><span>                l3<span style=color:#f92672>-&gt;</span>colour_next <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>*=</span> cachep<span style=color:#f92672>-&gt;</span>colour_off;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (local_flags <span style=color:#f92672>&amp;</span> __GFP_WAIT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * The test for missing atomic flag is performed here, rather than
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * the more obvious place, simply to reduce the critical path length
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * in kmem_cache_alloc(). If a caller is seriously mis-behaving they
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * will eventually be caught here (where it matters).
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem_flagcheck</span>(cachep, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Get mem for the objs.  Attempt to allocate a physical page from
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * &#39;nodeid&#39;.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>objp)
</span></span><span style=display:flex><span>                objp <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmem_getpages</span>(cachep, local_flags, nodeid);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>objp)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> failed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Get slab management. */</span>
</span></span><span style=display:flex><span>        slabp <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_slabmgmt</span>(cachep, objp, offset,
</span></span><span style=display:flex><span>                        local_flags <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>GFP_CONSTRAINT_MASK, nodeid);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>slabp)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> opps1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>slab_map_pages</span>(cachep, slabp, objp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cache_init_objs</span>(cachep, slabp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (local_flags <span style=color:#f92672>&amp;</span> __GFP_WAIT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>check_irq_off</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Make slab active. */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>list_add_tail</span>(<span style=color:#f92672>&amp;</span>slabp<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>(l3<span style=color:#f92672>-&gt;</span>slabs_free));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>STATS_INC_GROWN</span>(cachep);
</span></span><span style=display:flex><span>        l3<span style=color:#f92672>-&gt;</span>free_objects <span style=color:#f92672>+=</span> cachep<span style=color:#f92672>-&gt;</span>num;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>l3<span style=color:#f92672>-&gt;</span>list_lock);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>opps1:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem_freepages</span>(cachep, objp);
</span></span><span style=display:flex><span>failed:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (local_flags <span style=color:#f92672>&amp;</span> __GFP_WAIT)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=cache_init_objs>cache_init_objs()</h5><p>初始化 slab 的 kmem_bufctl 数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_init_objs</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>struct</span> slab <span style=color:#f92672>*</span>slabp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> cachep<span style=color:#f92672>-&gt;</span>num; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp <span style=color:#f92672>=</span> <span style=color:#a6e22e>index_to_obj</span>(cachep, slabp, i);
</span></span><span style=display:flex><span><span style=color:#75715e>#if DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>/* need to poison the objs? */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_POISON)
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>poison_obj</span>(cachep, objp, POISON_FREE);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_STORE_USER)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span><span style=color:#a6e22e>dbg_userword</span>(cachep, objp) <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_RED_ZONE) {
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span><span style=color:#a6e22e>dbg_redzone1</span>(cachep, objp) <span style=color:#f92672>=</span> RED_INACTIVE;
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span><span style=color:#a6e22e>dbg_redzone2</span>(cachep, objp) <span style=color:#f92672>=</span> RED_INACTIVE;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * Constructors are not allowed to allocate memory from the same
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * cache which they are a constructor for.  Otherwise, deadlock.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * They must also be threaded.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>ctor <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_POISON))
</span></span><span style=display:flex><span>                        cachep<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>ctor</span>(objp <span style=color:#f92672>+</span> <span style=color:#a6e22e>obj_offset</span>(cachep));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_RED_ZONE) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>dbg_redzone2</span>(cachep, objp) <span style=color:#f92672>!=</span> RED_INACTIVE)
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>slab_error</span>(cachep, <span style=color:#e6db74>&#34;constructor overwrote the&#34;</span>
</span></span><span style=display:flex><span>                                           <span style=color:#e6db74>&#34; end of an object&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>dbg_redzone1</span>(cachep, objp) <span style=color:#f92672>!=</span> RED_INACTIVE)
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>slab_error</span>(cachep, <span style=color:#e6db74>&#34;constructor overwrote the&#34;</span>
</span></span><span style=display:flex><span>                                           <span style=color:#e6db74>&#34; start of an object&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ((cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>%</span> PAGE_SIZE) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>OFF_SLAB</span>(cachep) <span style=color:#f92672>&amp;&amp;</span> cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_POISON)
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>kernel_map_pages</span>(<span style=color:#a6e22e>virt_to_page</span>(objp),
</span></span><span style=display:flex><span>                                         cachep<span style=color:#f92672>-&gt;</span>buffer_size <span style=color:#f92672>/</span> PAGE_SIZE, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (cachep<span style=color:#f92672>-&gt;</span>ctor)
</span></span><span style=display:flex><span>                        cachep<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>ctor</span>(objp);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>slab_bufctl</span>(slabp)[i] <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>slab_bufctl</span>(slabp)[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> BUFCTL_END;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=kmem_cache_free>kmem_cache_free</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_cache_free - Deallocate an object
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @cachep: The cache the allocation was from.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @objp: The previously allocated object.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Free an object which was previously allocated from this
</span></span></span><span style=display:flex><span><span style=color:#75715e> * cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>kmem_cache_free</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>objp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>local_irq_save</span>(flags);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>debug_check_no_locks_freed</span>(objp, <span style=color:#a6e22e>obj_size</span>(cachep));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_DEBUG_OBJECTS))
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>debug_check_no_obj_freed</span>(objp, <span style=color:#a6e22e>obj_size</span>(cachep));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>__cache_free</span>(cachep, objp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>local_irq_restore</span>(flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>trace_kmem_cache_free</span>(_RET_IP_, objp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(kmem_cache_free);
</span></span></code></pre></div><h2 id=kmem_cache_destroy>kmem_cache_destroy</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * kmem_cache_destroy - delete a cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @cachep: the cache to destroy
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Remove a &amp;struct kmem_cache object from the slab cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * It is expected this function will be called by a module when it is
</span></span></span><span style=display:flex><span><span style=color:#75715e> * unloaded.  This will remove the cache completely, and avoid a duplicate
</span></span></span><span style=display:flex><span><span style=color:#75715e> * cache being allocated each time a module is loaded and unloaded, if the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * module doesn&#39;t have persistent in-kernel storage across loads and unloads.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The cache must be empty before calling this function.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The caller must guarantee that noone will allocate memory from the cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> * during the kmem_cache_destroy().
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>kmem_cache_destroy</span>(<span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>cachep)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span>cachep <span style=color:#f92672>||</span> <span style=color:#a6e22e>in_interrupt</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Find the cache in the chain of caches. */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>get_online_cpus</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * the chain is never empty, cache_cache is never destroyed
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>list_del</span>(<span style=color:#f92672>&amp;</span>cachep<span style=color:#f92672>-&gt;</span>next);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>__cache_shrink</span>(cachep)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>slab_error</span>(cachep, <span style=color:#e6db74>&#34;Can&#39;t free all objects&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>list_add</span>(<span style=color:#f92672>&amp;</span>cachep<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>&amp;</span>cache_chain);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>put_online_cpus</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(cachep<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> SLAB_DESTROY_BY_RCU))
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>rcu_barrier</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>__kmem_cache_destroy</span>(cachep);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>cache_chain_mutex);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>put_online_cpus</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(kmem_cache_destroy);
</span></span></code></pre></div><h2 id=通用内存对象管理举例--zallockmalloc和kfree>通用内存对象管理举例 ： zalloc/kmalloc和kfree</h2><pre><code>	malloc_sizes 数组
</code></pre><h2 id=专用内存对象管理举例-task_struct>专用内存对象管理举例： task_struct</h2><h2 id=参考资料-2>参考资料</h2><p><a href=https://biscuitos.github.io/blog/HISTORY-SLAB/#D030063>SLAB Allocator</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Yuanye Ma</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-04-15</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a href=https://github.com/gohugoio/hugoBasicExample rel=noopener target=_blank>See origin</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/kernel-memory-manager/>Kernel memory manager</a>
<a href=/tags/slab/>slab</a></div><nav class=post-nav><a class=prev href=/post/os/linux-kernel/linux-kernel-makefiles/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i><span class="prev-text nav-default">Linux Kernel Makefiles</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/os/linux-kernel/linux-%E5%86%85%E6%A0%B8%E4%B8%B4%E6%97%B6%E9%A1%B5%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/><span class="next-text nav-default">Linux 内核临时页表初始化</span>
<span class="prev-text nav-mobile">Next</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div><nav class=toc id=toc><div class=toc-title>Table of Contents</div><div class="toc-content custom-scrollbar"><nav id=TableOfContents><ul><li><a href=#基本原理>基本原理</a></li><li><a href=#概念以及数据结构>概念以及数据结构</a><ul><li><a href=#struct-kmem_cache><code>struct kmem_cache</code></a></li><li><a href=#本地cpu空闲对象链表>本地CPU空闲对象链表</a></li><li><a href=#所有cpu共享的空闲对象链表>所有CPU共享的空闲对象链表</a></li><li><a href=#struct-kmem_list3><code>struct kmem_list3</code></a></li><li><a href=#sturct-slab><code>sturct slab</code></a></li><li><a href=#object>object</a></li><li><a href=#结构之间的关系>结构之间的关系</a></li><li><a href=#参考资料>参考资料</a></li></ul></li><li><a href=#kmem_cache_init>kmem_cache_init</a><ul><li><a href=#初始化前的准备工作>初始化前的准备工作</a></li><li><a href=#1-初始化cache_chain>1） 初始化<code>cache_chain</code></a></li><li><a href=#23-创建kmalloc用的高速缓存>2）&amp;3） 创建<code>kmalloc</code>用的高速缓存</a></li><li><a href=#4-用kmalloc对象替换静态分配的全局高速缓存变量>4） 用<code>kmalloc</code>对象替换静态分配的全局高速缓存变量</a></li><li><a href=#5-用kmalloc的空间替换静态分配的slab三链>5） 用<code>kmalloc</code>的空间替换静态分配的slab三链</a></li><li><a href=#6-enable_cpucache>6） <code>enable_cpucache</code></a></li><li><a href=#收尾工作>收尾工作</a></li><li><a href=#关于kmem_cache的初始化阶段>关于<code>kmem_cache</code>的初始化阶段</a></li><li><a href=#总结>总结</a></li><li><a href=#参考资料-1>参考资料</a></li></ul></li><li><a href=#kmem_cache_create>kmem_cache_create</a><ul><li><a href=#函数参数说明>函数参数说明</a></li><li><a href=#检查参数以及运行环境>检查参数以及运行环境</a></li><li><a href=#计算对齐>计算对齐</a></li><li><a href=#分配kmem_cache描述符>分配<code>kmem_cache</code>描述符</a></li><li><a href=#判断slab管理数据是放在slab内部还是外部>判断slab管理数据是放在slab内部还是外部</a></li><li><a href=#计算slab的容量>计算slab的容量</a></li><li><a href=#最终确定slab管理数据的存储位置>最终确定slab管理数据的存储位置</a></li><li><a href=#计算slab着色>计算slab着色</a></li><li><a href=#初始化slab构造函数>初始化slab构造函数</a></li><li><a href=#初始化本地以及共享的高速缓存>初始化本地以及共享的高速缓存</a></li><li><a href=#oops的处理流程>oops的处理流程</a></li></ul></li><li><a href=#kmem_cache_alloc>kmem_cache_alloc</a><ul><li></li></ul></li><li><a href=#kmem_cache_free>kmem_cache_free</a></li><li><a href=#kmem_cache_destroy>kmem_cache_destroy</a></li><li><a href=#通用内存对象管理举例--zallockmalloc和kfree>通用内存对象管理举例 ： zalloc/kmalloc和kfree</a></li><li><a href=#专用内存对象管理举例-task_struct>专用内存对象管理举例： task_struct</a></li><li><a href=#参考资料-2>参考资料</a></li></ul></nav></div></nav></div></main><footer id=footer class=footer><div class=icon-links><a href=yuanye.ma@qq.com rel="me noopener" class=iconfont title=email target=_blank><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a><a href=https://github.com/YuanyeMa rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" style="" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg>
</a><a href=https://www.zhihu.com/people/mr-kevin-92 rel="me noopener" class=iconfont title=zhihu target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z"/></svg>
</a><a href="https://space.bilibili.com/159072924?spm_id_from=333.1007.0.0" rel="me noopener" class=iconfont title=bilibili target=_blank><svg class="icon" style="" viewBox="0 0 1024 1024" width="36" height="36" id="svg8"><path style="" d="M744.60599.00486267A41.779915 41.779915.0 00710.4184 18.673394L548.5048 255.32642h-11.70046a41.779915 41.779915.0 00-10.80295-7.84928L235.66 97.084498a41.779915 41.779915.0 00-20.07193-4.960864 41.779915 41.779915.0 00-18.3748 79.145436L359.4859 255.32642H128.16909c-49.458302.0-89.27932 39.82105-89.27932 89.27932v508.65224c0 49.4583 39.821018 89.27934 89.27932 89.27934h19.48445C149.12802 984.5043 179.92773 1024 224.79179 1024c44.86407.0 75.66379-39.4957 77.13826-81.46268H719.98116C721.45559 984.5043 752.25533 1024 797.1194 1024c44.86406.0 75.6638-39.4957 77.13824-81.46268h21.57323c49.45831.0 89.27936-39.82104 89.27936-89.27934V344.60574c0-49.45827-39.82105-89.27932-89.27936-89.27932H649.74567L779.38103 65.866924A41.779915 41.779915.0 00744.60599.00486267zM644.49108 418.70871c6.29985.21538 12.44451 2.01107 17.86888 5.22196l171.36218 98.10771c18.23417 10.21935 24.63334 33.34627 14.24614 51.48533-10.38726 18.13909-33.57344 24.32718-51.61587 13.77296L624.9903 489.18895c-15.21356-8.41858-22.66871-26.1765-18.03211-42.93436 4.63664-16.75784 20.15573-28.14465 37.53289-27.54588zM350.2006 432.31846c16.89952.0317 31.69582 11.33328 36.17844 27.62747 4.48262 16.2942-2.44981 33.57765-16.95507 42.24898l-140.7157 86.91312c-17.68528 11.18244-41.09629 5.77692-52.08912-12.02686-10.99282-17.80373-5.33855-41.15658 12.58167-51.95857L329.9002 438.2095c6.0643-3.86439 13.10951-5.90891 20.3004-5.89104zM501.605 641.53985c3.75002-.15248 7.48645.53903 10.93349 2.0235.15842.0637.31618.12888.47325.19582.59328.27092 1.17574.56489 1.74609.88121.15868.0854.31643.17233.47325.2611.55694.32165 1.10131.66458 1.63185 1.02807.16455.1123.32777.2265.48956.34269.50382.36781.99371.75428 1.46868 1.15864.18724.15504.37218.31282.55484.47323.43271.38784.8518.79061 1.25653 1.20756.15449.16114.30679.32437.45693.48959.40798.44266.79989.89988 1.17494 1.37076.17799.22544.35205.45395.5222.68538.25932.34701.50964.70071.75064 1.06071.26712.39516.52286.79784.76699 1.20757.16907.29043.33231.58424.48957.88123.21836.41297.42513.83199.62009 1.25653.14836.32333.28983.64976.42429.97911.21319.51552.40915 1.03801.58747 1.5666.0677.19499.13296.39085.19582.58748.18652.60823.34984 1.22334.48957 1.84399.0397.16277.0779.32601.11423.48957.1436.69112.25788 1.38801.34269 2.08877.005.0381.0111.0761.0163.11424.0857.78056.13474 1.56471.14687 2.34988.005.0543.0111.10879.0163.1632.0.0-.008 1.12132.0 1.45234.0.0-.14697 17.84761 5.89102 34.12231 3.01902 8.13734 7.33278 15.10615 12.61433 19.61501 5.28157 4.50889 11.42894 7.62081 23.64572 7.62081 12.2168.0 18.36416-3.11192 23.64573-7.62081 5.28154-4.50886 9.5953-11.47767 12.6143-19.61501 6.03799-16.2747 5.89103-34.12231 5.89103-34.12231-.44885-13.87045 10.45922-25.46302 24.3311-25.86506 13.87189-.40201 25.42828 10.53953 25.78348 24.41272.0.0 1.11929 25.7226-9.00791 53.01927-5.06359 13.64832-13.1986 28.46036-27.05631 40.29073-13.85772 11.83039-33.5454 19.63135-56.20142 19.63135-22.65603.0-42.34371-7.80096-56.20141-19.63135-4.1801-3.56856-7.78733-7.42433-10.99878-11.42303-3.21235 4.00037-6.81703 7.85309-10.99876 11.42303-13.85773 11.83039-33.5454 19.63135-56.20144 19.63135-22.65601.0-42.3437-7.80096-56.2014-19.63135-13.85775-11.83037-21.99272-26.64241-27.05632-40.29073-10.12725-27.29667-9.00789-53.01928-9.00789-53.01927.20714-13.83687 11.58744-24.88848 25.42444-24.69013 14.1263.19991 25.2971 12.0278 24.69011 26.14247.0.0-.14697 17.84761 5.89103 34.12231 3.01902 8.13734 7.31646 15.10615 12.598 19.61501 5.28155 4.50889 11.44526 7.62081 23.66203 7.62081 12.21681.0 18.36418-3.11192 23.64573-7.62081 5.28154-4.50886 9.57899-11.47767 12.598-19.61501 5.76352-15.53489 5.89112-32.05691 5.89103-33.56746.006-.37466.0111-1.05336.0163-1.20759-.0117-.74583.0105-1.49177.0652-2.23565.009-.15784.0204-.31561.0327-.47324.14204-1.56859.43163-3.12027.86487-4.63449.0213-.0763.0433-.15244.0652-.22848 3.0335-10.25748 12.24157-17.46007 22.92769-17.93417z" id="rect824"/></svg>
</a><a href=/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span><span class=copyright-year>&copy;
2024
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i></span><span class=author>Yuanye Ma</span></span></div></footer><div class=button__back-to-top><a href=#back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></a></div></div><script type=text/javascript src=/lib/jquery/jquery-3.7.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/js/main.1f1ab71292e8ae0addbb90a5827f619e1cc7eba4a57b08930f33e5d8700d84be.js integrity="sha256-Hxq3EpLorgrdu5Clgn9hnhzH66SlewiTDzPl2HANhL4=" crossorigin=anonymous></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>